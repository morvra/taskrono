<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
	<meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="DTL" />
    <title>DailyTaskList</title>
    <script src="https://cdn.tailwindcss.com"></script>
	<link href='./dtlfavicon.ico' rel='icon' type='image/x-icon'/>
    <link href='./dtlicon.png' rel='shortcut icon'/>
    <link href='./dtlicon.png' rel='apple-touch-icon'/>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
		html, body { overscroll-behavior-y: contain; }
        body { font-family: 'Inter', sans-serif; background-color: #f3f4f6; }
        
        /* header for desktop */
        @media (min-width: 769px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
			.sections-wrapper { padding-bottom: 88px; }
			main { max-width: 980px; margin: 0 auto; }
        }
        
        /* Compact header for mobile */
        @media (max-width: 768px) {
            .header {
                background: white;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            }
            .mobile-compact-header .header-content {
                padding: 8px 16px !important;
                flex-direction: row !important;
                align-items: center !important;
            }
            .mobile-compact-header h1 {
                display: none;
            }
			p#current-date { color: #333; font-size: 1rem; }
            .mobile-compact-header .header-stats p:first-child {
                font-size: 0.7rem;
            }
            .mobile-compact-header .header-stats p:last-child {
                font-size: 1.1rem;
            }
            .mobile-nav {
                padding: 0 !important;
            }
            .mobile-nav .tab-link {
                padding: 6px 12px !important;
                font-size: 0.8rem !important;
            }
        }
        
        .tab-link.active { border-color: #3b82f6; background-color:#3b82f6; color:white; }
        .tab-content { display:none; }
        .tab-content.active { display:block; }
        .task-row.focused, .subtask-item.focused { background-color: #fef9c3; }
        .task-card.focused { background-color: #fef9c3; border-color: #eab308; }
        ::-webkit-scrollbar { width:8px; height:0px; }
        ::-webkit-scrollbar-track { background:#f1f1f1; border-radius:10px; }
        ::-webkit-scrollbar-thumb { background:#888; border-radius:10px; }
        ::-webkit-scrollbar-thumb:hover { background:#555; }

        .timer-btn {
            height: 31px;
            width: 31px;
            min-height: 31px;
            min-width: 31px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }
        .task-table th, .task-table td {
             padding-top: 0.25rem;
             padding-bottom: 0.1rem;
             padding-left: 0.5rem;
             padding-right: 0.5rem;
        }

		/* 新しいフローティングバーの基本スタイル */
		#floating-task-bar {
		    display: none;
		    align-items: center;
		    justify-content: space-between;
		    position: absolute;
		    left: 0;
		    right: 0;
		    top: 0;
		    will-change: transform;
		    transition: transform 80ms linear, opacity 0.25s ease-in-out;
		}

		#floating-task-bar.active {
		    display: flex; /* 表示 */
		}

        /* フローティングバー内の左右のボタン共通スタイル */
        .floating-bar-btn {
            height: 56px;
            width: 56px;
            min-width: 56px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            transition: all 0.15s;
        }
        .floating-bar-btn:active {
            transform: scale(0.95);
        }
		
		.fab {
            height: 56px;
            width: 56px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transition: all 0.2s ease-in-out;
        }
        .fab:hover {
			background-color: #ddd;
            box-shadow: 0 6px 16px rgba(0,0,0,0.2);
        }

		/* 同期ボタンコンテナのスタイル */
		#sync-button-floating-container {
		    position: absolute;
		    left: 16px;
		    top: 0;
		    z-index: 40;
		    will-change: transform;
		    transition: transform 80ms linear, opacity 0.3s ease-in-out;
		}

        /* タスク追加ボタンコンテナのスタイル (スマホでは非表示) */
        #add-task-floating-container {
            display: none;
            position: fixed;
            z-index: 40;
        }
        
        /* PC表示用の調整 (画面幅が769px以上の場合) */
        @media (min-width: 769px) {
            #sync-button-floating-container {
				position: fixed;
		        transform: none !important;
				top: auto;
                bottom: 24px;
                left: 24px;
            }

            #add-task-floating-container {
                display: block;
                bottom: 24px;
                right: 24px;
            }
        }
		.small-btn { min-height:44px; min-width:44px; display:inline-flex; align-items:center; justify-content:center; }
        .inline-input, .inline-select { width:100%; box-sizing:border-box; padding:6px 8px; border-radius:6px; border:1px solid #d1d5db; }
        .small-btn { padding:6px 8px; border-radius:6px; font-size:0.9rem; }

        .modal { display:none; position:fixed; z-index:1000; left:0; top:0; width:100%; height:100%; background-color:rgba(0,0,0,0.5); }
        .modal.active { display:flex; align-items:center; justify-content:center; }
        .modal-content { background:white; border-radius:8px; max-width:90vw; max-height:90vh; overflow-y:auto; }
		
		.tooltip-container { position: relative; display: inline-block; vertical-align: middle; }
		.custom-tooltip { visibility: hidden; opacity: 0; background-color: #2d3748; color: #fff; text-align: left; border-radius: 6px; padding: 8px 12px; position: absolute; z-index: 10; bottom: 150%; left: 50%; transform: translateX(-50%); transition: opacity 0.1s, visibility 0.1s; width: max-content; max-width: 300px; font-size: 0.875rem; font-weight: normal; line-height: 1.4; white-space: pre-wrap; box-shadow: 0 4px 6px rgba(0,0,0,0.1); pointer-events: none; }
		
		.dragging .custom-tooltip { position: static; transform: none; }
		.custom-tooltip::after { content: ""; position: absolute; top: 100%; left: 50%; margin-left: -5px; border-width: 5px; border-style: solid; border-color: #2d3748 transparent transparent transparent; }
        
        .tooltip-container:hover .custom-tooltip { 
            visibility: visible; 
            opacity: 1; 
            transition-delay: 0.1s; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-top { 
            bottom: 150%; 
            top: auto; 
        }
        .tooltip-container:hover .custom-tooltip.tooltip-bottom { 
            top: 150%; 
            bottom: auto; 
        }
        .custom-tooltip.tooltip-bottom::after { 
            top: -10px; 
            bottom: auto; 
            border-color: transparent transparent #2d3748 transparent; 
        }

        .dragging { opacity: 0.5; background-color: #fef9c3; transform: translate(0, 0); }
		.dragging .custom-tooltip,
		.dragging .tooltip-container:hover .custom-tooltip {
		    visibility: hidden !important;
		    opacity: 0 !important;
		    display: none !important;
		}
        .drag-over { background-color: #e0f2fe; }
        .drag-handle { cursor: move; color: #9ca3af; }
        .drag-handle:hover { color: #6b7280; }

        .archive-tabs { border-bottom: 1px solid #e5e7eb; }
        .archive-tab { padding: 8px 16px; cursor: pointer; border-bottom: 2px solid transparent; }
        .archive-tab.active { border-bottom-color: #3b82f6; background-color: #eff6ff; }
        .archive-tab:hover { background-color: #f3f4f6; }

        .time-input { width: 80px; text-align: center; border: 1px solid #d1d5db; border-radius: 4px; padding: 2px 4px; }

		.archive-search-box { display:flex; gap:8px; align-items:center; margin-bottom:12px; }
        .archive-search-input { flex:1; padding:8px 10px; max-width: 50%; border-radius:6px; border:1px solid #d1d5db; background:white; }
        .archive-search-btn { padding:8px 12px; border-radius:6px; background:#3b82f6; color:white; border:none; cursor:pointer; }
        .archive-clear-btn { padding:8px 10px; border-radius:6px; background:#e5e7eb; color:#374151; border:none; cursor:pointer; }
        .search-result-meta { font-size:0.85rem; color:#6b7280; }

        @media (max-width: 768px) {
            .tab-content.active { padding-bottom:160px; }
            .task-card-wrapper {
                space-y: 0.5rem; 
            }
            .task-card {
                border-radius: 0;
            }
            .task-card.completed {
                background-color: #e5e7eb; 
            }
            
            .archive-table-wrapper {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            .archive-table-wrapper > table {
                min-width: 640px; 
            }
            .archive-table-wrapper td, .archive-table-wrapper th {
                white-space: nowrap; 
            }
            .archive-table-wrapper .task-memo-cell {
                white-space: normal;
                min-width: 250px;
            }
        }
		/* サブタスク */
		.subtask-toggle-icon {
		    cursor: pointer;
		    display: inline-flex;
		    align-items: center;
		    gap: 2px;
		    font-size: 0.75rem;
		    color: #9ca3af;
		    padding: 0px 4px 2px;
		}
		.subtask-toggle-icon:hover {
		    color: #4b5563;
		}
		.subtask-container {
		    display: none; /* 初期状態は非表示 */
		    padding-left: 3.5rem; /* PC表示でのインデント */
		    background-color: #f9fafb;
		}
		.task-row.dragging + .subtask-container-row {
		    display: none;
		}
		.subtask-container-row td {
		    padding: 0;
		}
		.subtask-container.open {
		    display: block; /* 表示状態 */
		}
		.subtask-item {
		    display: flex;
		    align-items: center;
		    padding: 0.3rem 0.5rem;
		    border-bottom: 1px solid #f3f4f6;
		}
		.subtask-item:last-child {
		    border-bottom: none;
		}
		.subtask-item.completed span {
		    text-decoration: line-through;
		    color: #9ca3af;
		}
		.subtask-item .drag-handle {
		    margin-right: 0.5rem;
		}
		
		/* スマホ表示用の調整 */
		@media (max-width: 768px) {
		    .subtask-container {
		        padding-left: 0rem;
		        margin-left: .75rem;
				margin-top: 2px;
				box-shadow: 0px 3px 4px #ccc;
		    }
		}
		
		/* 編集モーダル内のサブタスクスタイル */
		#edit-task-subtasks, #edit-repeat-subtasks { max-height: 200px; overflow-y: auto; }
		.subtask-edit-item {
		    display: flex;
		    align-items: center;
		    gap: 0.5rem;
		    padding: 0.5rem;
		    background-color: #f9fafb;
		    border-radius: 6px;
		}
    </style>
</head>
<body class="antialiased text-gray-800">

<div class="header">
    <div class="container mx-auto">
		<header class="mobile-compact-header bg-white p-4 pb-1 flex flex-col md:flex-row justify-between items-center header-content">
            <div class="flex-1">
                <h1 class="text-xl font-bold text-gray-700">DailyTaskList</h1>
                <p id="current-date" class="text-sm text-gray-500"></p>
            </div>
            <div class="flex items-center">
                <div class="mt-2 md:mt-0 text-center md:text-right header-stats">
                    <p class="text-gray-600">全体の終了予測</p>
                    <p id="total-estimated-end-time" class="text-2xl font-semibold text-blue-600">--:--</p>
                </div>
            </div>
        </header>

        <nav class="mobile-nav flex space-x-0 overflow-x-auto">
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="today">当日のタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="repeat">リピートタスク</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="projects">プロジェクト</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="archive">アーカイブ</button>
            <button class="tab-link text-sm md:text-base py-1 px-4 text-gray-600 hover:bg-gray-100 hover:text-blue-600 transition-colors duration-200 flex-shrink-0" data-tab="data">データ管理</button>
        </nav>
    </div>
</div>

<div class="container mx-auto p-4 max-w-7xl">

    <main>
        <div id="today" class="tab-content space-y-4">
             <div class="flex justify-between items-center">
                 <div id="today-date-nav" class="flex items-center gap-2">
                    <button id="prev-day-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm">&lt;</button>
                    <h2 id="view-date-display" class="font-bold text-lg"></h2>
                    <button id="next-day-btn" class="p-2 rounded-md bg-white hover:bg-gray-100 shadow-sm">&gt;</button>
                 </div>
                <p class="text-sm text-gray-500 hidden md:block">キーボード: [↑][↓]選択, [Space]開始/停止, [P]先送り, [Ctrl+↑][↓]移動, [N]新規, [E]編集, [M]メモ, [D]削除</p>
            </div>
            <div id="sections-container" class="sections-wrapper"></div>
        </div>

        <div id="repeat" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">リピートタスク管理</h2>
                <div class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4 items-end">
                    <input type="text" id="repeat-task-name" placeholder="タスク名" class="md:col-span-2 p-2 border rounded-lg"  autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
                    <div class="grid grid-cols-2 gap-4">
                        <input type="number" id="repeat-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                        <select id="repeat-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
                    </div>
                    <select id="repeat-task-type" class="p-2 border rounded-lg bg-white md:col-span-2">
                        <option value="daily">毎日</option>
                        <option value="weekly">毎週</option>
                        <option value="monthly">毎月</option>
                        <option value="interval">○日ごと</option>
                    </select>
                </div>

                <div class="mb-4">
                    <textarea id="repeat-task-memo" placeholder="メモ (任意)" class="w-full p-2 border rounded-lg h-11"></textarea>
                </div>

                <div id="repeat-weekly-options" class="hidden flex flex-wrap gap-x-4 gap-y-2 mb-4 p-3 bg-gray-50 rounded-lg"></div>
                <div id="repeat-monthly-options" class="hidden mb-4 p-3 bg-gray-50 rounded-lg">
                    <label class="text-sm">日付: <input type="number" id="repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
                </div>
                <div id="repeat-interval-options" class="hidden mb-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
                    <label class="text-sm">何日ごと: <input type="number" id="repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
                    <label class="text-sm">基準日: <input type="date" id="repeat-interval-start-date" class="p-2 border rounded-lg"></label>
                </div>

                <div class="flex gap-3">
                    <button id="add-repeat-task-btn" class="w-full bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ リピートタスクを追加</button>
                    <button id="generate-from-repeat-btn" class="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">▶ 今日のタスクを生成</button>
                </div>

                <div id="repeat-tasks-container" class="mt-6"></div>
            </div>
        </div>

        <div id="projects" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">プロジェクト管理</h2>
                <div class="flex flex-wrap gap-4 items-center mb-4">
                    <input type="text" id="project-name" placeholder="プロジェクト名" class="flex-grow p-2 border rounded-lg">
                    <input type="color" id="project-color" value="#4a90e2" class="p-1 h-10 w-12 border rounded-lg">
                    <button id="add-project-btn" class="bg-purple-500 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded-lg transition-colors duration-200 shadow">＋ プロジェクトを追加</button>
                </div>
                <div id="projects-container" class="mt-6"></div>
            </div>
        </div>
        
        <div id="archive" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <div class="archive-tabs flex mb-4">
                    <div class="archive-tab active" data-view="date">日付</div>
                    <div class="archive-tab" data-view="project">プロジェクト</div>
					<div class="archive-tab" data-view="search">検索</div>
                </div>
                
                <div id="archive-date-view">
                    <div class="flex justify-between items-center mb-4">
                        <button id="prev-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&lt;</button>
                        <h2 id="archive-date" class="font-bold"></h2>
                        <button id="next-archive-day" class="p-2 rounded-md bg-gray-200 hover:bg-gray-300">&gt;</button>
                    </div>
                    <div id="archive-tasks-list"></div>
                </div>

                <div id="archive-project-view" class="hidden">
                    <div class="mb-4">
                        <select id="archive-project-select" class="p-2 border rounded-lg bg-white">
                            <option value="">プロジェクトを選択</option>
                        </select>
                    </div>
                    <div id="archive-project-tasks"></div>
                </div>

				<div id="archive-search-view" class="hidden">
    				<div class="archive-search-box">
        				<input id="archive-search-input" class="archive-search-input" type="text" placeholder="タスク名またはメモを検索">
        				<button id="archive-search-btn" class="archive-search-btn">検索</button>
        				<button id="archive-clear-btn" class="archive-clear-btn">クリア</button>
    				</div>
    				<div id="archive-search-results"></div>
				</div>
				
            </div>
        </div>

        <div id="data" class="tab-content">
            <div class="bg-white p-6 rounded-lg shadow-md">
                <h2 class="text-xl font-bold mb-4">データ管理</h2>
                <div class="space-y-6">
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">Dropbox</h3>
                        <p class="text-sm text-gray-600 mb-3">タスクデータをDropboxに保存し、他のデバイスと同期します。</p>
                        <div id="auth-container">
                            <button id="authorize_button" class="bg-blue-700 hover:bg-blue-800 text-white font-bold py-2 px-4 rounded-lg">Dropbox ログイン</button>
                        </div>
                        <div id="signout_container" class="hidden">
                            <p id="auth-status" class="text-sm text-green-600 mb-2"></p>
                            <button id="signout_button" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">ログアウト</button>
                        </div>
                        <p id="drive-status" class="text-sm text-gray-500 mt-2"></p>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データエクスポート</h3>
                        <p class="text-sm text-gray-600 mb-3">現在のデータをJSONファイルとしてダウンロードします。</p>
                        <button id="export-data-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-lg">データをエクスポート</button>
                    </div>
                    <div class="border p-4 rounded-lg">
                        <h3 class="text-lg font-semibold mb-3">データインポート</h3>
                        <p class="text-sm text-gray-600 mb-3">JSONファイルからデータを復元します。IDが重複するデータは上書きされ、存在しないデータは追加されます。</p>
                        <input type="file" id="import-file" accept=".json" class="mb-3 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100">
                        <button id="import-data-btn" class="bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-lg">データをインポート</button>
                    </div>
                    <div class="border p-4 rounded-lg border-red-200">
                        <h3 class="text-lg font-semibold mb-3 text-red-700">データ削除</h3>
                        <p class="text-sm text-gray-600 mb-3">全てのデータを削除します。この操作は元に戻せません。</p>
                        <button id="clear-data-btn" class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-lg">全データを削除</button>
                    </div>
                </div>
            </div>
        </div>
    </main>
</div>

<div id="sync-button-floating-container"></div>
<div id="add-task-floating-container"></div>

<div id="floating-task-bar" class="bg-white shadow-[0_-2px_10px_rgba(0,0,0,0.1)] h-20 px-4 z-50">
    <div id="floating-task-bar-content" class="flex items-center justify-between w-full h-full"></div>
</div>

<div id="add-task-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを追加</h3>
        <div class="space-y-4">
            <input type="text" id="new-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true" >
            <input type="number" id="new-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg" value="5">
            <select id="new-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-new-task-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">追加</button>
            <button id="cancel-add-task-btn" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>


<div id="task-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">タスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-task-name" placeholder="タスク名" class="w-full p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
            <div class="grid grid-cols-2 gap-4">
                 <input type="number" id="edit-task-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                 <select id="edit-task-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
            <textarea id="edit-task-memo" placeholder="メモ" class="w-full p-2 border rounded-lg" rows="1"></textarea>
			
            <div class="mt-2">
                <div class="flex items-center justify-between">
                    <label class="text-sm font-medium text-gray-700">サブタスク</label>
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="task-subtask-toggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <div id="task-subtask-content" class="hidden mt-2">
                    <div id="edit-task-subtasks" class="space-y-2 p-2 border rounded-lg bg-gray-50"></div>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="new-subtask-name" placeholder="新しいサブタスク名" class="flex-1 p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
                        <button id="add-subtask-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg">追加</button>
                    </div>
                </div>
            </div>
			
            <div class="grid grid-cols-2 gap-4">
                 <div>
                    <label for="edit-task-startTime" class="text-sm font-medium text-gray-700">開始時刻</label>
                    <input type="time" id="edit-task-startTime" class="w-full p-2 border rounded-lg">
                </div>
                <div>
                    <label for="edit-task-endTime" class="text-sm font-medium text-gray-700">終了時刻</label>
                    <input type="time" id="edit-task-endTime" class="w-full p-2 border rounded-lg">
                </div>
            </div>
        </div>
        <div class="flex gap-3 mt-6">
            <button id="save-task-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-task-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
            <button id="create-repeat-from-task" class="flex-1 bg-green-500 hover:bg-green-600 text-white py-2 px-2 rounded-lg">リピート作成</button>
        </div>
    </div>
</div>

<div id="memo-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-md">
        <h3 class="text-lg font-bold mb-4">メモを編集</h3>
        <textarea id="edit-memo-text" placeholder="メモを入力..." class="w-full p-2 border rounded-lg h-32"></textarea>
        <div class="flex gap-3 mt-6">
            <button id="save-memo-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-memo-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="repeat-edit-modal" class="modal">
    <div class="modal-content p-6 w-full max-w-lg">
        <h3 class="text-lg font-bold mb-4">リピートタスクを編集</h3>
        <div class="space-y-4">
            <input type="text" id="edit-repeat-name" placeholder="タスク名" class="w-full p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
             <div class="grid grid-cols-2 gap-4">
                <input type="number" id="edit-repeat-time" placeholder="見積時間(分)" class="w-full p-2 border rounded-lg">
                <select id="edit-repeat-project" class="w-full p-2 border rounded-lg bg-white"></select>
            </div>
            <textarea id="edit-repeat-memo" placeholder="メモ" class="w-full p-2 border rounded-lg" rows="1"></textarea>
			
            <div class="mt-2">
                <div class="flex items-center justify-between">
                    <label class="text-sm font-medium text-gray-700">サブタスク</label>
                    <label class="inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="repeat-subtask-toggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                    </label>
                </div>
                <div id="repeat-subtask-content" class="hidden mt-2">
                    <div id="edit-repeat-subtasks" class="space-y-2 mt-1 p-2 border rounded-lg bg-gray-50"></div>
                    <div class="flex gap-2 mt-2">
                        <input type="text" id="new-repeat-subtask-name" placeholder="新しいサブタスク名" class="flex-1 p-2 border rounded-lg" autocomplete="one-time-code" data-form-type="other" data-lpignore="true">
                        <button id="add-repeat-subtask-btn" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-bold py-2 px-4 rounded-lg">追加</button>
                    </div>
                </div>
            </div>
			
            <select id="edit-repeat-type" class="w-full p-2 border rounded-lg bg-white">
                <option value="daily">毎日</option>
                <option value="weekly">毎週</option>
                <option value="monthly">毎月</option>
                <option value="interval">○日ごと</option>
            </select>
        </div>

        <div id="edit-repeat-weekly-options" class="hidden flex flex-wrap gap-x-4 gap-y-2 mt-4 p-3 bg-gray-50 rounded-lg"></div>
        <div id="edit-repeat-monthly-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg">
            <label class="text-sm">日付: <input type="number" id="edit-repeat-monthly-day" placeholder="1～31" class="p-2 border rounded-lg w-24" min="1" max="31"></label>
        </div>
        <div id="edit-repeat-interval-options" class="hidden mt-4 p-3 bg-gray-50 rounded-lg space-y-2 md:space-y-0 md:items-center md:space-x-4">
            <label class="text-sm">何日ごと: <input type="number" id="edit-repeat-interval-days" placeholder="例: 3" class="p-2 border rounded-lg w-24" min="1"></label>
            <label class="text-sm">基準日: <input type="date" id="edit-repeat-interval-start-date" class="p-2 border rounded-lg"></label>
        </div>

        <div class="flex gap-3 mt-6">
            <button id="save-repeat-edit" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-4 rounded-lg">保存</button>
            <button id="cancel-repeat-edit" class="flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-4 rounded-lg">キャンセル</button>
        </div>
    </div>
</div>

<div id="toast-notification" class="fixed top-5 right-1 bg-green-600 text-white mx-2 py-2 px-4 rounded-lg shadow-md transition-all duration-500 ease-in-out transform -translate-y-20 opacity-0 z-[2000]"></div>
<div id="reauth-notification" class="fixed top-5 right-1 bg-yellow-500 text-white mx-2 py-2 px-4 rounded-lg shadow-md transition-all duration-500 ease-in-out transform -translate-y-20 opacity-0 z-[2000] items-center gap-3 hidden">
    <span>Dbに再ログインが必要です。</span>
    <button id="reauth-button" class="bg-white text-yellow-600 font-bold py-1 px-3 rounded-lg hover:bg-yellow-100">ログイン</button>
</div>

<script src="https://unpkg.com/dropbox/dist/Dropbox-sdk.min.js"></script>

<script>

    document.addEventListener('DOMContentLoaded', () => {

        // --- フローティング要素のキーボード追従と滑らかスクロール対策 ---
		function setupFloatingElementsStick() {
		    const bar = document.getElementById('floating-task-bar');
		    const syncButtonContainer = document.getElementById('sync-button-floating-container');
		
		    if (!bar || !syncButtonContainer) return;
		
		    let ticking = false;
		
		function updateElementsPosition() {
		    const bar = document.getElementById('floating-task-bar');
		    const syncButtonContainer = document.getElementById('sync-button-floating-container');
		    if (!bar || !syncButtonContainer) return;
		
		    // PC表示時の処理 (変更なし)
		    if (!isMobile()) {
				bar.style.position = ''; 
	            bar.style.bottom = '';
		        bar.style.top = '';
		        syncButtonContainer.style.position = '';
		        syncButtonContainer.style.bottom = '';
		        syncButtonContainer.style.top = '';
		        return;
		    }
		
		    // モバイル表示時の処理 (absolute + 無限スクロール制限)
		    const scrollY = window.scrollY || 0;
		    const viewportHeight = window.innerHeight;
		    const actualBarHeight = bar.offsetHeight;
		    const barHeight = actualBarHeight > 0 ? actualBarHeight : 80;
		
		    const documentHeight = Math.max(
		        document.body.scrollHeight, 
		        document.documentElement.scrollHeight,
		        document.body.offsetHeight, 
		        document.documentElement.offsetHeight
		    );
		    
		    const maxScroll = documentHeight - viewportHeight;
		    const absoluteBottomTop = documentHeight - barHeight;
		
		    let newBarTop;
		    let newSyncButtonTop;
		    
		    if (scrollY >= maxScroll) {
		        newBarTop = absoluteBottomTop;
		        
		    } 
		    else {
		        const scrollBottom = scrollY + viewportHeight;
		        newBarTop = scrollBottom - barHeight;
		    }
		    bar.style.position = 'absolute';
		    bar.style.top = newBarTop + 'px';
		    const syncButtonHeight = syncButtonContainer.offsetHeight;
		    newSyncButtonTop = newBarTop - syncButtonHeight - 16;
		    syncButtonContainer.style.position = 'absolute';
		    syncButtonContainer.style.top = newSyncButtonTop + 'px';		    
		}
		
		    function requestTick() {
		        if (!ticking) {
		            requestAnimationFrame(() => {
		                updateElementsPosition();
		                ticking = false;
		            });
		            ticking = true;
		        }
		    }
		
		    // 初期実行
		    updateElementsPosition();
		    if (isMobile()) {
		        // スクロール位置を0にしてから、requestAnimationFrameで強制的に再計算させる
		        window.scrollTo(0, 0); 
		        requestTick();
		    }
		
		    // イベントリスナー
		    window.addEventListener('scroll', requestTick, { passive: true });
		    window.addEventListener('resize', requestTick);
		    
		    // visualViewportのイベントも追加（キーボード表示時の対応）
		    if (window.visualViewport) {
		        window.visualViewport.addEventListener('resize', requestTick);
		        window.visualViewport.addEventListener('scroll', requestTick);
		    }
		}

        // --- DROPBOX SYNC START ---
        const dailyTaskListApp = window.dailyTaskListApp = {
            dropboxFilePath: '/DailyTaskListData.json', // Dropbox App Folder内のパス
            dbx: null,
            saveTimeout: null,
            // DOM Elements
            authorizeButton: document.getElementById('authorize_button'),
            signoutButton: document.getElementById('signout_button'),
            authContainer: document.getElementById('auth-container'),
            signoutContainer: document.getElementById('signout_container'),
            authStatusEl: document.getElementById('auth-status'),
            driveStatusEl: document.getElementById('drive-status'),
			syncDataFab: document.getElementById('sync-button-floating-container'),
		    reauthNotification: document.getElementById('reauth-notification'),
		    reauthButton: document.getElementById('reauth-button'),
            updateReauthUi: function(show) {
                if (show) {
                    this.reauthNotification.classList.remove('hidden');
                    // 少し遅延させてから表示アニメーションを開始
                    setTimeout(() => {
                        this.reauthNotification.classList.remove('-translate-y-20', 'opacity-0');
                        this.reauthNotification.style.display = 'flex';
                    }, 50);
                } else {
                    this.reauthNotification.classList.add('-translate-y-20', 'opacity-0');
                    // アニメーション完了後に非表示にする
                    setTimeout(() => {
                        this.reauthNotification.classList.add('hidden');
                        this.reauthNotification.style.display = 'none';
                    }, 500);
                }
            },
			
            updateAuthUi: function(isLoggedIn) {
		        this.authContainer.classList.toggle('hidden', isLoggedIn);
		        this.signoutContainer.classList.toggle('hidden', !isLoggedIn);
		        
		        if (isLoggedIn) {
		            this.authStatusEl.textContent = 'Dropboxにログイン済みです。';
		            this.syncDataFab.innerHTML = `
		                <button id="sync-data-btn-floating" class="fab bg-white text-blue-60"> 
		                    <svg xmlns="http://www.w3.org/2000/svg" class="h-7 w-7" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" />
                            </svg>
		                </button>
		            `;
		            this.syncDataFab.querySelector('#sync-data-btn-floating').addEventListener('click', () => {
		                this.loadStateFromDropbox();
		            });
		
		        } else {
		            this.driveStatusEl.textContent = 'ログインするとデータを同期できます。';
		            this.syncDataFab.innerHTML = '';
		        }
		    },

			loadStateFromDropbox: async function() {
                if (!this.dbx) {
                    alert('Dropboxにログインしてください。');
                    return;
                }
                this.driveStatusEl.textContent = 'Dropboxからデータを読み込み中...';
                try {
                    const response = await this.dbx.filesDownload({ path: this.dropboxFilePath });
                    const fileContent = await response.result.fileBlob.text();
                    const importedData = JSON.parse(fileContent);

					// --- Custom Merge Logic for dailyTasks ---
					const driveDailyTasks = importedData.dailyTasks || {};
					const localDailyTasks = state.dailyTasks;
					const allDailyDates = new Set([...Object.keys(localDailyTasks), ...Object.keys(driveDailyTasks)]);

					const sortedDates = Array.from(new Set([
					    ...Object.keys(state.dailyTasks), 
					    ...Object.keys(state.archivedTasks)
					])).sort();
					const repeatTaskCompletionMap = new Map();
					
					allDailyDates.forEach(date => {
					    const localTasksForDate = localDailyTasks[date] || [];
					    const driveTasksForDate = driveDailyTasks[date] || [];
					    const combinedTasks = [...localTasksForDate, ...driveTasksForDate];
					    const taskMap = new Map();
					
					    for (const task of combinedTasks) {
					        const key = task.originRepeatId
					            ? `repeat-${task.originRepeatId}-${task.createdDate || ''}`
					            : `task-${task.id}`;
					
					        if (!taskMap.has(key)) {
					            taskMap.set(key, task);
					        } else {
					            const existingTask = taskMap.get(key);
					            const newTask = task;
					
					            // 競合解決ロジック: 完了状態を優先し、それ以外は更新日時が新しい方を採用する
					            const existingIsCompleted = getTaskStatus(existingTask) === 'completed';
					            const newIsCompleted = getTaskStatus(newTask) === 'completed';
					
					            let taskToKeep = existingTask; // デフォルトは既存のタスクを維持
					
					            // 1. 完了状態を優先
					            if (newIsCompleted && !existingIsCompleted) {
					                // 新しいタスクが完了していて、既存が未完了なら新しい方を採用
					                taskToKeep = newTask;
					            } else if (!newIsCompleted && existingIsCompleted) {
					                // 既存のタスクが完了していて、新しい方が未完了なら既存を維持 (何もしない)
					            } else {
					                // 2. 完了状態が同じ場合は、更新日時で比較
					                // updatedAtが存在しない古いデータのために、フォールバック値を設定
					                const existingTimestamp = existingTask.updatedAt || '1970-01-01T00:00:00.000Z';
					                const newTimestamp = newTask.updatedAt || '1970-01-01T00:00:00.000Z';
					                
					                if (newTimestamp >= existingTimestamp) {
					                    taskToKeep = newTask;
					                }
					            }
					            taskMap.set(key, taskToKeep);
					        }
					    }
					    
					    let mergedTasks = Array.from(taskMap.values());
					
					    // Sort the final list based on the saved sortOrder.
					    // Fallback to 0 for older tasks that don't have the property.
					    mergedTasks.sort((a, b) => (a.sortOrder || 0) - (b.sortOrder || 0));
					    
					    state.dailyTasks[date] = mergedTasks;
					});
					
					// 各リピートタスクの完了状態を収集
					sortedDates.forEach(date => {
					    const tasks = state.dailyTasks[date] || [];
					    tasks.forEach(task => {
					        if (task.originRepeatId && getTaskStatus(task) === 'completed') {
					            const existing = repeatTaskCompletionMap.get(task.originRepeatId);
					            if (!existing || date > existing) {
					                repeatTaskCompletionMap.set(task.originRepeatId, date);
					            }
					        }
					    });
					});
					
					// 次に、完了日より後の日付にある同じリピートタスク由来の未完了タスクを削除
					sortedDates.forEach(date => {
					    const tasks = state.dailyTasks[date] || [];
					    state.dailyTasks[date] = tasks.filter(task => {
					        if (!task.originRepeatId) return true; // リピートタスク由来でなければ保持
					        
					        const completedDate = repeatTaskCompletionMap.get(task.originRepeatId);
					        if (!completedDate) return true; // 完了記録がなければ保持
					        
					        // このタスクの作成日が完了日以前で、かつ未完了なら削除候補
					        const taskCreatedDate = task.createdDate || date;
					        if (taskCreatedDate > completedDate) {
					            // 完了日より後に作成されたタスク = 新しい日のリピート生成なので保持
					            return true;
					        }
					        
					        if (getTaskStatus(task) === 'completed') {
					            // 完了済みなら保持
					            return true;
					        }
					        
					        // ここに到達するのは: 完了日以前に作成され、未完了のタスク
					        // = 日をまたぐ際にコピーされたが、元が完了済みだったタスク
					        // ただし、同じ日付内での重複は除外(毎日リピートの当日分は保持)
					        if (taskCreatedDate === date) {
					            return true; // 当日作成のタスクは保持
					        }
					        
					        return false; // 削除
					    });
					});
					// --- End of dailyTasks Merge Logic ---
					
					// --- Custom Merge Logic for archivedTasks ---
                    const driveArchivedTasks = importedData.archivedTasks || {};
                    const localArchivedTasks = state.archivedTasks;
                    const allArchiveDates = new Set([...Object.keys(localArchivedTasks), ...Object.keys(driveArchivedTasks)]);
                    allArchiveDates.forEach(date => {
                        const localTasks = localArchivedTasks[date] || [];
                        const driveTasks = driveArchivedTasks[date] || [];
                        const taskMap = new Map();
                        for (const task of [...localTasks, ...driveTasks]) {
                            taskMap.set(task.id, task);
                        }
                        state.archivedTasks[date] = Array.from(taskMap.values());
                    });
                    // --- End of archivedTasks Merge Logic ---
					
					// 各リピートタスクの完了状態を収集
					sortedDates.forEach(date => {
					    // dailyTasksから
					    const dailyTasks = state.dailyTasks[date] || [];
					    dailyTasks.forEach(task => {
					        if (task.originRepeatId && getTaskStatus(task) === 'completed') {
					            const existing = repeatTaskCompletionMap.get(task.originRepeatId);
					            if (!existing || date > existing) {
					                repeatTaskCompletionMap.set(task.originRepeatId, date);
					            }
					        }
					    });
					    
					    // archivedTasksからも確認
					    const archivedTasks = state.archivedTasks[date] || [];
					    archivedTasks.forEach(task => {
					        if (task.originRepeatId && getTaskStatus(task) === 'completed') {
					            const existing = repeatTaskCompletionMap.get(task.originRepeatId);
					            if (!existing || date > existing) {
					                repeatTaskCompletionMap.set(task.originRepeatId, date);
					            }
					        }
					    });
					});
					
					// 完了日より後の日付にある同じリピートタスク由来の未完了タスクを削除
					sortedDates.forEach(date => {
					    const tasks = state.dailyTasks[date] || [];
					    state.dailyTasks[date] = tasks.filter(task => {
					        if (!task.originRepeatId) return true;
					        
					        const completedDate = repeatTaskCompletionMap.get(task.originRepeatId);
					        if (!completedDate) return true;
					        
					        const taskCreatedDate = task.createdDate || date;
					        if (taskCreatedDate > completedDate) {
					            return true;
					        }
					        
					        if (getTaskStatus(task) === 'completed') {
					            return true;
					        }
					        
					        if (taskCreatedDate === date) {
					            return true;
					        }
					        return false;
					    });
					});
					// --- End of リピートタスク重複削除処理 ---

                    if (importedData.projects) state.projects = importedData.projects;
                    if (importedData.repeatTasks) state.repeatTasks = importedData.repeatTasks;
                    state.lastDate = importedData.lastDate || state.lastDate;
                    
                    stopActiveTimer();
                    state.viewDate = getFormattedDate(new Date());
                    const tasksToday = getTasksForViewDate();
	                const firstUncompletedTask = tasksToday.find(t => getTaskStatus(t) !== 'completed');
	                if (firstUncompletedTask) {
	                    state.focusedTaskId = firstUncompletedTask.id;
	                } else if (tasksToday.length > 0) {
	                    state.focusedTaskId = tasksToday[tasksToday.length - 1].id;
	                } else {
	                    state.focusedTaskId = null;
	                }
                    Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
                    
                    restoreRunningTaskState();
					saveState(); 
                    render();
                    this.driveStatusEl.textContent = `Dropboxからデータを読み込みました (${new Date().toLocaleTimeString()})。`;
                    showToast('Dropboxからデータを読み込みました。');

                } catch (error) {
                    if (error.status === 409) { // 409: path not found
                         this.driveStatusEl.textContent = 'データファイルが見つかりません。初回同期を開始します...';
                         await this.saveStateToDropbox(); // 初回保存
                    } else {
                        console.error('Error loading state from Dropbox:', error);
                        this.driveStatusEl.textContent = `読み込みエラー: ${error.error?.error_summary || 'Unknown error'}`;
						const errorSummary = error.error?.error_summary || '';
                        if (error.status === 401 || errorSummary.includes('expired_access_token')) {
                            this.updateReauthUi(true);
                            this.driveStatusEl.textContent = '認証が切れました。再ログインしてください。';
                        }
                    }
                }
            },
            
			saveStateToDropbox: async function() {
			    const accessToken = localStorage.getItem('dropbox_access_token');
			    if (!this.dbx || !accessToken) {
			        console.log('Dropbox not authenticated, skipping cloud save');
			        return;
			    }
			    
			    this.driveStatusEl.textContent = 'Dropboxへ保存準備中...';
			    const cleanedDailyTasks = {};
			    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
			
			    for (const dateKey in state.dailyTasks) {
			        const filteredTasks = state.dailyTasks[dateKey].filter(task => {
			            // isDeletedフラグがないか、あっても30日以内のものだけを残す
			            return !task.isDeleted || (task.updatedAt && task.updatedAt > thirtyDaysAgo);
			        });
			        // フィルタリングした結果、タスクが1件以上残っている場合のみ、その日付のデータを保存する
			        if (filteredTasks.length > 0) {
			            cleanedDailyTasks[dateKey] = filteredTasks;
			        }
			    }
			    
			    const dataToSave = {
			        dailyTasks: cleanedDailyTasks,
			        projects: state.projects,
			        repeatTasks: state.repeatTasks,
			        archivedTasks: state.archivedTasks,
			        lastDate: state.lastDate,
			        updatedAt: new Date().toISOString()
			    };
			    
			    this.driveStatusEl.textContent = 'Dropboxへ保存中...';
			    try {
			        await this.dbx.filesUpload({
			            path: this.dropboxFilePath,
			            contents: JSON.stringify(dataToSave, null, 2),
			            mode: 'overwrite'
			        });
			        this.driveStatusEl.textContent = `Dropboxに保存しました (${new Date().toLocaleTimeString()})。`;
			    } catch (error) {
			        console.error('Error saving state to Dropbox:', error);
			        this.driveStatusEl.textContent = `保存エラー: ${error.error?.error_summary || 'Unknown error'}`;
			        if (error.status === 401) { // 認証エラー
			            this.updateAuthUi(false);
			            this.driveStatusEl.textContent = '認証が切れました。再ログインしてください。';
			            this.updateReauthUi(true);
			        }
			    }
			}
        };
        
		// Dropbox 同期機能の初期化
		async function initializeDropboxSync() {
		    // ここにDropboxアプリのクライアントIDを設定してください
		    const DROPBOX_CLIENT_ID = '0fno7q10xgfdyki';
		    const REDIRECT_URI = window.location.origin + window.location.pathname; 
		    // 例: https://morvra.github.io/dtl または https://morvra.github.io/dtl/
		
		    if (DROPBOX_CLIENT_ID === 'YOUR_CLIENT_ID') {
		        console.warn("DropboxのクライアントIDが設定されていません。");
		        dailyTaskListApp.authorizeButton.textContent = '設定が必要です';
		        dailyTaskListApp.authorizeButton.disabled = true;
		        return;
		    }
		
            // localStorageからトークンを読み込み、インスタンス作成時に渡す
            const accessToken = localStorage.getItem('dropbox_access_token');
            const refreshToken = localStorage.getItem('dropbox_refresh_token');

		    const dbx = new Dropbox.Dropbox({ 
                clientId: DROPBOX_CLIENT_ID,
                accessToken,
                refreshToken
            });

			dailyTaskListApp.dbx = dbx; // アプリケーションオブジェクトにインスタンスをセット

			dailyTaskListApp.reauthButton.addEventListener('click', () => {
                dailyTaskListApp.authorizeButton.click();
            });
		
		    // URLに認証コードがあるか確認 (OAuthリダイレクト後)
		    const urlParams = new URLSearchParams(window.location.search);
		    const authCode = urlParams.get('code');
		
		    if (authCode) {
		        try {
		            // --- PKCE: 認証開始時に保存した code_verifier を復元 ---
		            const savedVerifier = sessionStorage.getItem('dropbox_pkce_code_verifier');
		            if (savedVerifier && dbx && dbx.auth) {
		                try { dbx.auth.codeVerifier = savedVerifier; } catch (e) { /* ignore */ }
		            }
		
		            // 認証コードをアクセストークンとリフレッシュトークンに交換
		            const response = await dbx.auth.getAccessTokenFromCode(REDIRECT_URI, authCode);
                    
		            const { result } = response;
                    const newAccessToken = result.access_token;
                    const newRefreshToken = result.refresh_token;
		
		            // 交換が成功したら、保存しておいた verifier は削除
		            sessionStorage.removeItem('dropbox_pkce_code_verifier');
		
		            // URLから認証コードを削除してクリーンにする
		            window.history.replaceState({}, document.title, window.location.pathname);
                    
		            localStorage.setItem('dropbox_access_token', newAccessToken);
                    if (newRefreshToken) {
		                localStorage.setItem('dropbox_refresh_token', newRefreshToken);
                    }
		            dbx.auth.setAccessToken(newAccessToken);
                    if (newRefreshToken) {
		                dbx.auth.setRefreshToken(newRefreshToken);
                    }

		            dailyTaskListApp.updateAuthUi(true);
					dailyTaskListApp.updateReauthUi(false);
		            dailyTaskListApp.loadStateFromDropbox();

		        } catch (error) {
		            console.error('Error getting access token from code:', error);
		            const detail =
		                (error && (error.error_summary || error.error || error.error_description)) ||
		                JSON.stringify(error);
		            dailyTaskListApp.driveStatusEl.textContent = `認証交換エラー: ${detail}`;
		            alert('Dropboxの認証に失敗しました。詳細はコンソールを確認してください。');
		        }
		    } else {
		        // ローカルストレージにトークンがあるか確認
		        if (accessToken) {
		            // トークンの有効性を確認（このAPI呼び出しにより、期限切れならSDKが自動でリフレッシュを試みる）
		            try {
		                await dbx.usersGetCurrentAccount();
		                dailyTaskListApp.updateAuthUi(true);
						dailyTaskListApp.updateReauthUi(false);
		                dailyTaskListApp.loadStateFromDropbox();
		            } catch (error) {
		                // トークンが無効だった場合（リフレッシュも失敗した場合）
		                console.error('Stored token invalid:', error);
		                localStorage.removeItem('dropbox_access_token');
		                localStorage.removeItem('dropbox_refresh_token');
		                dailyTaskListApp.dbx = null;
		                dailyTaskListApp.updateAuthUi(false);
						dailyTaskListApp.updateReauthUi(true);
		            }
		        } else {
		            dailyTaskListApp.updateAuthUi(false);
		        }
		    }
		
		    // --- 認証開始処理 ---
		    dailyTaskListApp.authorizeButton.addEventListener('click', async () => {
		        try {
		            const authUrl = await dbx.auth.getAuthenticationUrl(
		                REDIRECT_URI,         // Redirect URI
		                undefined,            // state
		                'code',               // authType
		                'offline',            // 'offline'を指定してリフレッシュトークンを要求
		                undefined,            // scope
		                undefined,            // includeGrantedScopes
		                true                  // usePKCE
		            );
		            // SDKが生成した code_verifier を sessionStorage に保存
		            try {
		                const codeVerifier = dbx.auth && dbx.auth.codeVerifier;
		                if (codeVerifier) {
		                    sessionStorage.setItem('dropbox_pkce_code_verifier', codeVerifier);
		                }
		            } catch (e) {
		                console.warn('Failed to store Dropbox PKCE code_verifier:', e);
		            }
		            // ユーザーをDropboxの認証ページへリダイレクト
		            window.location.href = authUrl;
		        } catch (e) {
		            console.error('Error creating Dropbox auth URL:', e);
		            alert('Dropbox認証用URLの生成に失敗しました。');
		        }
		    });
		
		    // --- ログアウト処理 ---
		    dailyTaskListApp.signoutButton.addEventListener('click', async () => {
		        if (!dailyTaskListApp.dbx) return;
		        try {
		            await dailyTaskListApp.dbx.authTokenRevoke();
		        } catch (error) {
		            console.error('Failed to revoke token', error);
		        } finally {
		            localStorage.removeItem('dropbox_access_token');
		            localStorage.removeItem('dropbox_refresh_token');
		            dailyTaskListApp.dbx = null;
		            dailyTaskListApp.updateAuthUi(false);
					dailyTaskListApp.updateReauthUi(false);
		        }
		    });
		}
		// --- DROPBOX SYNC END ---

        function showToast(message, duration = 3000) {
            const toast = document.getElementById('toast-notification');
            if (!toast) return;

            toast.textContent = message;
            toast.classList.remove('-translate-y-20', 'opacity-0');

            // 一定時間後に非表示
            setTimeout(() => {
                toast.classList.add('-translate-y-20', 'opacity-0');
            }, duration);
        }

        // State
        const state = {
            dailyTasks: {}, 
            projects: [],
            repeatTasks: [],
            archivedTasks: {},
            viewDate: null, 
            lastDate: null,
            archiveViewDate: null,
            archiveView: 'date',
            selectedArchiveProject: '',
            settings: {
                dayChangeHour: 4, 
            },
            activeTimerId: null,
            activeTaskId: null,
            focusedTaskId: null,
			focusedSubtaskId: null,
			openTaskIds: new Set(),
            editingTaskId: null,
            editingTaskDateKey: null, 
            editingRepeatId: null,
            editingMemoTaskId: null
        };

        // DOM refs
        const tabs = document.querySelectorAll('.tab-link');
        const currentDateEl = document.getElementById('current-date');
        const totalEstimatedEndTimeEl = document.getElementById('total-estimated-end-time');

		function updateSortOrderAndTimestamps(dateKey) {
			const tasks = state.dailyTasks[dateKey] || [];
			const now = new Date().toISOString();
			tasks.forEach((task, index) => {
				task.sortOrder = index;
				// Only update the timestamp if the order actually changed
				// to avoid unnecessary saves during simple reads.
				if (!task.updatedAt || task.sortOrder !== index) {
					task.updatedAt = now;
				}
			});
		}

		// サブタスク関連
		function toggleSubtaskView(taskId) {
            // stateの更新（どのタスクが開いているかの情報を更新）
		    if (state.openTaskIds.has(taskId)) {
		        state.openTaskIds.delete(taskId);
		    } else {
		        state.openTaskIds.add(taskId);
		    }

		    if (taskId === state.focusedTaskId) {
		        saveAndRender();
		    } else {
		        const subtaskContainer = document.getElementById(`subtasks-${taskId}`);
		        if (subtaskContainer) {
		            subtaskContainer.classList.toggle('open', state.openTaskIds.has(taskId));
		        }
		        saveState();
		    }
	    }

	
		function toggleSubtaskCompletion(taskId, subtaskId, isCompleted) {
			const task = getTasksForViewDate().find(t => t.id === taskId);
			if (task && task.subtasks) {
				const subtask = task.subtasks.find(st => st.id === subtaskId);
				if (subtask) {
					subtask.completed = isCompleted;
					task.updatedAt = new Date().toISOString();

                    Array.from(document.querySelectorAll(`.subtask-item [data-subtask-id="${subtaskId}"]`)).forEach(checkbox => {
                        const item = checkbox.closest('.subtask-item');
                        if (item) {
                            item.classList.toggle('completed', isCompleted);
                            checkbox.checked = isCompleted;
                        }
                    });

					saveState();
				}
			}
		}
	
	    function renderSubtasksInModal(type, taskId) {
	        const isRepeat = type === 'repeat';
	        const container = document.getElementById(isRepeat ? 'edit-repeat-subtasks' : 'edit-task-subtasks');
	        const task = isRepeat ? state.repeatTasks.find(t => t.id === taskId) : getTasksForViewDate().find(t => t.id === taskId);
	        
	        container.innerHTML = '';
	        if (!task || !task.subtasks) return;
	
	        task.subtasks.forEach((st, index) => {
	            const item = document.createElement('div');
	            item.className = 'subtask-edit-item';
	            item.dataset.subtaskId = st.id;
	
	            item.innerHTML = `
	                <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" ${st.completed ? 'checked' : ''} ${isRepeat ? 'disabled' : ''}>
	                <input type="text" class="flex-1 p-1 border rounded-md" value="${escapeHtml(st.name)}">
					<div class="flex items-center">
						<button class="subtask-move-up-btn text-gray-400 hover:text-blue-500 p-1" title="上へ移動">
							<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" /></svg>
						</button>
						<button class="subtask-move-down-btn text-gray-400 hover:text-blue-500 p-1" title="下へ移動">
							<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
						</button>
						<button class="subtask-delete-btn text-gray-400 hover:text-red-500 p-1" title="削除">
							<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
						</button>
					</div>
	            `;
	            container.appendChild(item);
	        });
	
			// イベントリスナーが重複しないようにフラグで管理
			if (!container.dataset.listenersAdded) {
				// イベント委任でクリックを処理
				container.addEventListener('click', (e) => {
					const item = e.target.closest('.subtask-edit-item');
					if (!item) return;

					if (e.target.closest('.subtask-delete-btn')) {
						item.remove();
					} else if (e.target.closest('.subtask-move-up-btn')) {
						if (item.previousElementSibling) {
							item.parentElement.insertBefore(item, item.previousElementSibling);
						}
					} else if (e.target.closest('.subtask-move-down-btn')) {
						if (item.nextElementSibling) {
							item.parentElement.insertBefore(item.nextElementSibling, item);
						}
					}
				});
		
				// モーダル内サブタスクのキーボード並び替え
				container.addEventListener('keydown', (e) => {
					if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
						 if (e.ctrlKey || e.metaKey) {
							e.preventDefault();
							const currentItem = e.target.closest('.subtask-edit-item');
							if (!currentItem) return;
							
							if (e.key === 'ArrowUp' && currentItem.previousElementSibling) {
								currentItem.parentElement.insertBefore(currentItem, currentItem.previousElementSibling);
								e.target.focus();
							} else if (e.key === 'ArrowDown' && currentItem.nextElementSibling) {
								currentItem.parentElement.insertBefore(currentItem.nextElementSibling, currentItem);
								e.target.focus();
							}
						}
					}
				});
				container.dataset.listenersAdded = 'true';
			}
	    }
	    
	    function addSubtaskToModal(type, name) {
	        const isRepeat = type === 'repeat';
	        const container = document.getElementById(isRepeat ? 'edit-repeat-subtasks' : 'edit-task-subtasks');
	        
	        const item = document.createElement('div');
	        item.className = 'subtask-edit-item';
	        item.dataset.subtaskId = 'new-st-' + Date.now();
	        
	        item.innerHTML = `
	            <input type="checkbox" class="form-checkbox h-4 w-4 text-blue-600" ${isRepeat ? 'disabled' : ''}>
	            <input type="text" class="flex-1 p-1 border rounded-md" value="${escapeHtml(name)}">
				<div class="flex items-center">
					<button class="subtask-move-up-btn text-gray-400 hover:text-blue-500 p-1" title="上へ移動">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M5 15l7-7 7 7" /></svg>
					</button>
					<button class="subtask-move-down-btn text-gray-400 hover:text-blue-500 p-1" title="下へ移動">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 9l-7 7-7-7" /></svg>
					</button>
					<button class="subtask-delete-btn text-gray-400 hover:text-red-500 p-1" title="削除">
						<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" /></svg>
					</button>
				</div>
	        `;
	        container.appendChild(item);
	        // イベントリスナーは親コンテナで委任されているため、個別に追加する必要はありません
	        item.querySelector('input[type="text"]').focus();
	    }
	
	    function getSubtasksFromModal(type) {
	        const isRepeat = type === 'repeat';
	        const container = document.getElementById(isRepeat ? 'edit-repeat-subtasks' : 'edit-task-subtasks');
	        const subtaskItems = container.querySelectorAll('.subtask-edit-item');
	        const subtasks = [];
	        subtaskItems.forEach(item => {
	            const name = item.querySelector('input[type="text"]').value.trim();
	            if (name) {
	                subtasks.push({
	                    id: item.dataset.subtaskId.startsWith('new-st-') ? 'st' + Date.now() + Math.random() : item.dataset.subtaskId,
	                    name: name,
	                    completed: isRepeat ? false : item.querySelector('input[type="checkbox"]').checked
	                });
	            }
	        });
	        return subtasks;
	    }

        // Init
        function init() {
            state.viewDate = getFormattedDate(new Date());
            loadState();
			handleUrlScheme();
            restoreRunningTaskState();
            setupEventListeners();
            initializeDropboxSync();
			renderPcAddTaskButton();
            checkDayChange();
            setInterval(checkDayChange, 1000 * 60); 
            updateTitle();
            
            render();
            updateTimeDisplays();
            setInterval(updateTimeDisplays, 1000*30);
            
            window.addEventListener('resize', () => {
                const activeTab = document.querySelector('.tab-link.active').dataset.tab;
                if (['today', 'repeat', 'projects', 'archive'].includes(activeTab)) {
                    render();
                }
				renderFloatingTaskBar();
            });

            setupFloatingElementsStick(); 
        }

	function handleUrlScheme() {
	    const urlParams = new URLSearchParams(window.location.search);
	    const taskNameParam = urlParams.get('addtask');
	
	    if (!taskNameParam) return;
	
	    const taskName = taskNameParam;
	    const estimatedRaw = urlParams.get('estimated');
	    const estimatedParsed = parseInt(estimatedRaw, 10);
	    const estimatedTime = (!isNaN(estimatedParsed) && estimatedParsed >= 0) ? estimatedParsed : 5;
	    const projectName = urlParams.get('project') || null;
	
	    let projectId = null;
	    if (projectName) {
	        const project = state.projects.find(p => p.name.toLowerCase() === projectName.toLowerCase());
	        if (project) projectId = project.id;
	    }
	
	    try {
	        const cleanUrl = window.location.protocol + '//' + window.location.host + window.location.pathname + (window.location.hash || '');
	        window.history.replaceState(null, '', cleanUrl);
	    } catch (e) {
	        console.warn('URL クリーンアップに失敗しました（続行します）:', e);
	    }
	
    // タスク追加処理を「1フレーム遅らせて」実行する
    setTimeout(() => {
        try {
            // 「当日のタスク」タブを強制的に開く（存在チェック）
            document.querySelector('.tab-link[data-tab="today"]')?.click();

            // 表示日を今日にする
            state.viewDate = getFormattedDate(new Date());

            if (typeof addTask !== 'function') {
                console.warn('addTask 関数が見つかりません。URL追加をスキップします。');
                return;
            }

            const newTask = addTask(taskName, estimatedTime, projectId);

            if (newTask) {
                showToast(`「${taskName}」を追加しました。`);
            }
        } catch (err) {
            console.error('URL からのタスク追加で一部処理が失敗しました:', err);
            showToast('URLからのタスク追加中に一部処理が失敗しました（詳細はコンソール）。', 5000);
        }
    }, 0);
	}

    function getTasksForViewDate() {
        const tasks = state.dailyTasks[state.viewDate] || [];
        return tasks.filter(task => !task.isDeleted);
    }

	function setTasksForViewDate(tasks) {
	    const deletedTasks = (state.dailyTasks[state.viewDate] || []).filter(task => task.isDeleted);
	    state.dailyTasks[state.viewDate] = [...tasks, ...deletedTasks];
	}

	function updateTitle() {
        const activeTask = getTasksForViewDate().find(t => t.id === state.activeTaskId);
        if (activeTask) {
            document.title = `⏱ ${activeTask.name} - DTL`;
        } else {
            document.title = 'DailyTaskList';
        }
    }

    function isMobile() {
        return window.innerWidth <= 768;
    }

    function getFormattedDate(date) {
        return new Date(date.getTime() - (state.settings.dayChangeHour * 60 * 60 * 1000))
            .toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit' })
            .replace(/\//g, '-');
    }

    function getTaskStatus(task) {
        if (task.startTime && task.endTime) {
            return 'completed';
        } else if (task.startTime && !task.endTime) {
            return 'running';
        } else {
            return 'pending';
        }
    }

    function updateTaskStatus(task) {
        const tasks = getTasksForViewDate();
        const oldStatus = task.status;
        task.status = getTaskStatus(task);
        
        if (oldStatus !== 'completed' && task.status === 'completed') {
            moveTaskToCompletedSection(task.id);
        }
        else if (oldStatus !== 'running' && task.status === 'running') {
            moveTaskToTop(task.id);
        }
    }

    function moveTaskToCompletedSection(taskId) {
        const tasks = getTasksForViewDate();
        const taskIndex = tasks.findIndex(t => t.id === taskId);
        if (taskIndex === -1) return;

        const [task] = tasks.splice(taskIndex, 1);
        
        const lastCompletedIndex = tasks.map(t => t.status === 'completed').lastIndexOf(true);
        
        const insertIndex = lastCompletedIndex === -1 ? 0 : lastCompletedIndex + 1;

        tasks.splice(insertIndex, 0, task);
        setTasksForViewDate(tasks);
    }

	function moveTaskToTop(taskId) {
	    const tasks = getTasksForViewDate();
	    const taskIndex = tasks.findIndex(t => t.id === taskId);
	    if (taskIndex !== -1) {
	        const task = tasks[taskIndex];
	        const uncompletedTasks = tasks.filter(t => t.status !== 'completed' && t.id !== taskId);
	
	        if (uncompletedTasks.length === 0) {
	            return;
	        }
	
	        const [movedTask] = tasks.splice(taskIndex, 1);
	        const firstUncompletedIndex = tasks.findIndex(t => t.status !== 'completed');
	        
	        const insertIndex = firstUncompletedIndex !== -1 ? firstUncompletedIndex : 0;
	        
	        tasks.splice(insertIndex, 0, movedTask);
	        setTasksForViewDate(tasks);
	    }
	}

    function positionTooltip(tooltipContainer) {
        const tooltip = tooltipContainer.querySelector('.custom-tooltip');
        const rect = tooltipContainer.getBoundingClientRect();
        const tooltipRect = tooltip.getBoundingClientRect();
        
        if (rect.top - tooltipRect.height < 10) {
            tooltip.classList.add('tooltip-bottom');
            tooltip.classList.remove('tooltip-top');
        } else {
            tooltip.classList.add('tooltip-top');
            tooltip.classList.remove('tooltip-bottom');
        }
    }

    function loadState() {
        const defaults = {
            dailyTasks: {},
            projects: [
                { id: 'p' + Date.now(), name: '仕事', color: '#4a90e2' },
                { id: 'p' + (Date.now()+1), name: '学習', color: '#50e3c2' },
                { id: 'p' + (Date.now()+2), name: 'プライベート', color: '#f5a623' },
            ],
            repeatTasks: [],
            archivedTasks: {},
            lastDate: getFormattedDate(new Date()),
        };

        const oldTasks = localStorage.getItem('dtl_tasks');
        const newTasks = localStorage.getItem('dtl_dailyTasks');
        if (oldTasks && !newTasks) {
            const parsedOldTasks = JSON.parse(oldTasks);
            if (Array.isArray(parsedOldTasks) && parsedOldTasks.length > 0) {
                const today = getFormattedDate(new Date());
                state.dailyTasks[today] = parsedOldTasks;
                localStorage.removeItem('dtl_tasks');
            }
        }
        
        Object.keys(defaults).forEach(k => {
            const saved = localStorage.getItem(`dtl_${k}`);
            if ((k === 'archivedTasks' || k === 'dailyTasks') && !saved) {
                state[k] = defaults[k];
            } else {
                 state[k] = saved ? JSON.parse(saved) : defaults[k];
            }
        });
        
        Object.values(state.dailyTasks).flat().forEach(task => {
            updateTaskStatus(task);
        });
    }

	function saveState() {
	    Object.keys(state).forEach(k => {
	        if (k !== 'settings' && k !== 'archiveView' && k !== 'selectedArchiveProject') {
	            if (k === 'openTaskIds') {
	                localStorage.setItem(`dtl_${k}`, JSON.stringify(Array.from(state[k])));
	            } else {
	                localStorage.setItem(`dtl_${k}`, JSON.stringify(state[k]));
	            }
	        }
	    });
	
	    const savedOpenTaskIds = localStorage.getItem('dtl_openTaskIds');
	    if (savedOpenTaskIds) {
	        state.openTaskIds = new Set(JSON.parse(savedOpenTaskIds));
	    }
	    
	    const app = window.dailyTaskListApp;
	    const accessToken = localStorage.getItem('dropbox_access_token');
	    if (app.dbx && accessToken) { // Dropboxインスタンスとトークンの両方が存在する場合のみ
	        if (app.saveTimeout) clearTimeout(app.saveTimeout);
	        app.saveTimeout = setTimeout(() => app.saveStateToDropbox(), 2000);
	    }
	}

    function restoreRunningTaskState() {
        // 既に動いているタイマーがあれば止める
        stopActiveTimer();

        const tasks = getTasksForViewDate();
        const runningTask = tasks.find(t => t.status === 'running');
        
        if (runningTask) {
            state.activeTaskId = runningTask.id;
            state.activeTimerId = setInterval(() => {
                // 実行中のタスクの最新の状態を取得
                const currentTask = getTasksForViewDate().find(t => t.id === state.activeTaskId);
                // タスクが存在し、かつ実行中であることを確認
                if (!currentTask || currentTask.status !== 'running') {
                    stopActiveTimer(); // 状態が変化していればタイマーを停止
                    updateTitle();
                    renderFloatingTaskBar();
                    return;
                }
                const currentActualTime = calculateActualTime(currentTask);
                const timeEl = document.querySelector(`[data-task-id="${currentTask.id}"] .time-actual`);
                if (timeEl) {
                    timeEl.textContent = formatTime(currentActualTime);
                }
            }, 1000);
        }
    }
		
    function checkDayChange() {
        const today = getFormattedDate(new Date());
        if (state.lastDate !== today) {
            console.log(`Date changed: ${state.lastDate} -> ${today}`);

			const yesterdaysTasks = state.dailyTasks[state.lastDate];
            if (yesterdaysTasks && yesterdaysTasks.length > 0) {
                // isDeletedでない未完了タスクのみを抽出
                const leftoverTasks = yesterdaysTasks.filter(t => t.status !== 'completed' && !t.isDeleted);
                if (leftoverTasks.length > 0) {
                    if (!state.dailyTasks[today]) {
                        state.dailyTasks[today] = [];
                    }
                    state.dailyTasks[today].unshift(...leftoverTasks);
                    // 昨日分のタスクリストからは、持ち越したタスクと完了済みタスク以外（論理削除済みも含む）を更新
                    state.dailyTasks[state.lastDate] = yesterdaysTasks.filter(t => t.status === 'completed' || t.isDeleted);
                }
            }
            
            archiveCompletedTasks(state.lastDate);
            generateTasksFromRepeatAuto(today);
            state.lastDate = today;
            state.viewDate = today; 
            const tasksToday = state.dailyTasks[today] || [];
            const firstUncompletedTaskOnDayChange = tasksToday.find(t => getTaskStatus(t) !== 'completed');
            if (firstUncompletedTaskOnDayChange) {
                state.focusedTaskId = firstUncompletedTaskOnDayChange.id;
            } else if (tasksToday.length > 0) {
                state.focusedTaskId = tasksToday[tasksToday.length - 1].id;
            } else {
                state.focusedTaskId = null;
            }
			saveAndRender();
        }
    }

	function archiveCompletedTasks(dateKey) {
        if (!state.dailyTasks[dateKey]) return;
        // isDeletedでない完了タスクのみをアーカイブ対象とする
        const completedTasks = state.dailyTasks[dateKey].filter(t => t.status === 'completed' && !t.isDeleted);
        if (completedTasks.length > 0) {
            if (!state.archivedTasks[dateKey]) {
                state.archivedTasks[dateKey] = [];
            }
            // 既にアーカイブにあるタスクは追加しないようにチェック
            const existingIds = new Set(state.archivedTasks[dateKey].map(t => t.id));
            const newTasksToArchive = completedTasks.filter(t => !existingIds.has(t.id));
            state.archivedTasks[dateKey].push(...newTasksToArchive);
            // isDeletedフラグが立っているタスクか、未完了のタスクのみを残す
            state.dailyTasks[dateKey] = state.dailyTasks[dateKey].filter(t => t.isDeleted || t.status !== 'completed');
        }
    }

    function generateTasksFromRepeatAuto(dateStr) {
        const today = new Date(dateStr);
        today.setMinutes(today.getMinutes() + today.getTimezoneOffset());
        
        const dayOfWeek = today.getDay();
        const dayOfMonth = today.getDate();

        if (!state.dailyTasks[dateStr]) {
            state.dailyTasks[dateStr] = [];
        }

        state.repeatTasks.forEach(rt => {
            let shouldAdd = false;
            
            if (rt.type === 'daily') shouldAdd = true;
            else if (rt.type === 'weekly' && Array.isArray(rt.value) && rt.value.includes(dayOfWeek)) shouldAdd = true;
            else if (rt.type === 'monthly' && rt.value == dayOfMonth) shouldAdd = true;
            else if (rt.type === 'interval' && rt.startDate && rt.value > 0) {
                const start = new Date(rt.startDate);
                start.setMinutes(start.getMinutes() + start.getTimezoneOffset());
                const diffTime = today.getTime() - start.getTime();
                const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
                if (diffDays >= 0 && diffDays % rt.value === 0) shouldAdd = true;
            }

            if (shouldAdd) {
                const isAlreadyAdded = state.dailyTasks[dateStr].some(task => task.originRepeatId === rt.id);
                if (!isAlreadyAdded) {
					const newSubtasks = (rt.subtasks || []).map(st => ({...st, completed: false}));
					
                    state.dailyTasks[dateStr].push({
                        id: 't' + Date.now() + Math.random(),
                        name: rt.name,
                        projectId: rt.projectId || null,
                        estimatedTime: rt.estimatedTime || 0,
                        actualTime: 0,
                        status: 'pending',
                        isInterrupt: false,
                        memo: rt.memo || '',
						subtasks: newSubtasks,
                        originRepeatId: rt.id,
                        createdDate: dateStr,
                        startTime: null,
                        endTime: null,
                    });
                }
            }
        });
    }

    function generateTasksFromRepeatManual() {
        const todayStr = getFormattedDate(new Date());
        
        if (!state.dailyTasks[todayStr]) {
            state.dailyTasks[todayStr] = [];
        }
        let tasksForToday = state.dailyTasks[todayStr];

        let addedCount = 0;
        const tasksBefore = tasksForToday.length;
        
        generateTasksFromRepeatAuto(todayStr);

        const tasksAfter = state.dailyTasks[todayStr].length;
        addedCount = tasksAfter - tasksBefore;

        if (addedCount > 0) {
            state.focusedTaskId = tasksForToday.length > 0 ? tasksForToday[tasksForToday.length-1].id : null;
            saveAndRender();
            alert(addedCount + ' 件のタスクを生成しました。');
        } else {
            alert('今日生成できるリピートタスクはありません（既に生成済みか該当なし）。');
        }
    }

    function generateSingleRepeatTask(repeatTaskId) {
        const rt = state.repeatTasks.find(t => t.id === repeatTaskId);
        if (!rt) return;

        const today = getFormattedDate(new Date());
        if (!state.dailyTasks[today]) state.dailyTasks[today] = [];
        const tasksForToday = state.dailyTasks[today];
        
        const existingTask = tasksForToday.find(t => 
            t.originRepeatId === repeatTaskId && 
            t.createdDate === today
        );
        
        if (existingTask) {
            alert('このリピートタスクは既に今日のタスクとして存在します。');
            return;
        }
		const newSubtasks = (rt.subtasks || []).map(st => ({...st, completed: false}));

        const newTask = {
            id: 't' + Date.now() + Math.random(),
            name: rt.name,
            projectId: rt.projectId || null,
            estimatedTime: rt.estimatedTime || 0,
            actualTime: 0,
            status: 'pending',
            isInterrupt: false,
            memo: rt.memo || '',
			subtasks: newSubtasks,
            originRepeatId: rt.id,
            createdDate: today,
            startTime: null,
            endTime: null,
        };

        const lastPendingIndex = tasksForToday.map(t => t.status).lastIndexOf('pending');
        const lastRunningIndex = tasksForToday.map(t => t.status).lastIndexOf('running');
        const lastUncompletedIndex = Math.max(lastPendingIndex, lastRunningIndex);
        
        const insertIndex = lastUncompletedIndex !== -1 ? lastUncompletedIndex + 1 : tasksForToday.length;
        tasksForToday.splice(insertIndex, 0, newTask);
        setTasksForViewDate(tasksForToday);

        state.focusedTaskId = newTask.id;
        state.viewDate = today;
        saveAndRender();
        alert('今日のタスクとして追加しました。');
    }

    function setupEventListeners() {
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                tabs.forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
                
                if (tab.dataset.tab === 'today') {
                    const tasks = getTasksForViewDate();
                    const firstUncompletedTask = tasks.find(t => getTaskStatus(t) !== 'completed');
                    if (firstUncompletedTask) {
                        state.focusedTaskId = firstUncompletedTask.id;
                    } else if (tasks.length > 0) {
                        state.focusedTaskId = tasks[tasks.length - 1].id;
                    } else {
                        state.focusedTaskId = null;
                    }
                } else if (tab.dataset.tab === 'archive') {
                    if (!state.archiveViewDate) {
                        const yesterday = new Date();
                        yesterday.setDate(yesterday.getDate() - 1);
                        state.archiveViewDate = getFormattedDate(yesterday);
                    }
                }
                render();
            });
        });
        document.querySelector('.tab-link[data-tab="today"]').click();

        document.getElementById('add-project-btn').addEventListener('click', addProject);
        document.getElementById('add-repeat-task-btn').addEventListener('click', addRepeatTask);
        document.getElementById('generate-from-repeat-btn').addEventListener('click', generateTasksFromRepeatManual);
        
        document.getElementById('repeat-task-type').addEventListener('change', (e) => {
            document.getElementById('repeat-weekly-options').classList.toggle('hidden', e.target.value !== 'weekly');
            document.getElementById('repeat-monthly-options').classList.toggle('hidden', e.target.value !== 'monthly');
            document.getElementById('repeat-interval-options').classList.toggle('hidden', e.target.value !== 'interval');
            if (e.target.value === 'interval') {
                const startDateInput = document.getElementById('repeat-interval-start-date');
                if (!startDateInput.value) {
                    startDateInput.value = new Date().toISOString().slice(0, 10);
                }
            }
        });
        
        document.getElementById('prev-day-btn').addEventListener('click', () => moveViewDate(-1));
        document.getElementById('next-day-btn').addEventListener('click', () => moveViewDate(1));
        document.getElementById('prev-archive-day').addEventListener('click', () => moveArchiveDate(-1));
        document.getElementById('next-archive-day').addEventListener('click', () => moveArchiveDate(1));

        document.querySelectorAll('.archive-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.archive-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                state.archiveView = tab.dataset.view;
                renderArchive();
            });
        });

        document.getElementById('archive-project-select').addEventListener('change', (e) => {
            state.selectedArchiveProject = e.target.value;
            renderArchiveProjectView();
        });

		const searchBtn = document.getElementById('archive-search-btn');
		const searchInput = document.getElementById('archive-search-input');
		const clearBtn = document.getElementById('archive-clear-btn');
		if (searchBtn && searchInput && clearBtn) {
    		searchBtn.addEventListener('click', () => {
        		const q = searchInput.value.trim();
        		renderArchiveSearchView(q);
    		});
    		clearBtn.addEventListener('click', () => {
        		searchInput.value = '';
        		renderArchiveSearchView('');
    		});
    		searchInput.addEventListener('keydown', (e) => {
        		if (e.key === 'Enter') {
            		e.preventDefault();
            		const q = searchInput.value.trim();
            		renderArchiveSearchView(q);
        		}
    		});
		}

        document.getElementById('export-data-btn').addEventListener('click', exportData);
        document.getElementById('import-data-btn').addEventListener('click', importData);
        document.getElementById('clear-data-btn').addEventListener('click', clearAllData);

        setupModalEvents();

		function autoHeightListener(event) {
            // 高さを一度リセットしてからスクロール量に合わせて再設定
            event.target.style.height = 'auto';
            event.target.style.height = (event.target.scrollHeight) + 'px';
        }
        document.getElementById('edit-task-memo').addEventListener('input', autoHeightListener);
        document.getElementById('edit-repeat-memo').addEventListener('input', autoHeightListener);


        document.addEventListener('keydown', handleKeyboardShortcuts);
        
        document.addEventListener('mouseover', (e) => {
            const tooltipContainer = e.target.closest('.tooltip-container');
            if (tooltipContainer) {
                setTimeout(() => positionTooltip(tooltipContainer), 10);
            }
        });
    }

    function setupModalEvents() {
        document.getElementById('save-new-task-btn').addEventListener('click', () => {
             addTask(
                document.getElementById('new-task-name').value,
                document.getElementById('new-task-time').value,
                document.getElementById('new-task-project').value
            );
            closeModal('add-task-modal');
        });
        document.getElementById('cancel-add-task-btn').addEventListener('click', () => closeModal('add-task-modal'));
        
        document.getElementById('save-task-edit').addEventListener('click', saveTaskEdit);
        document.getElementById('cancel-task-edit').addEventListener('click', () => closeModal('task-edit-modal'));
        document.getElementById('create-repeat-from-task').addEventListener('click', createRepeatFromTask);

        document.getElementById('edit-memo-text').addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                saveMemoEdit();
            }
        });
        document.getElementById('save-memo-edit').addEventListener('click', saveMemoEdit);
        document.getElementById('cancel-memo-edit').addEventListener('click', () => closeModal('memo-edit-modal'));

        document.getElementById('save-repeat-edit').addEventListener('click', saveRepeatEdit);
        document.getElementById('cancel-repeat-edit').addEventListener('click', () => closeModal('repeat-edit-modal'));
        document.getElementById('edit-repeat-type').addEventListener('change', (e) => {
            document.getElementById('edit-repeat-weekly-options').classList.toggle('hidden', e.target.value !== 'weekly');
            document.getElementById('edit-repeat-monthly-options').classList.toggle('hidden', e.target.value !== 'monthly');
            document.getElementById('edit-repeat-interval-options').classList.toggle('hidden', e.target.value !== 'interval');
             if (e.target.value === 'interval') {
                const startDateInput = document.getElementById('edit-repeat-interval-start-date');
                if (!startDateInput.value) {
                    startDateInput.value = new Date().toISOString().slice(0, 10);
                }
            }
        });

        document.getElementById('new-task-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                if (document.getElementById('new-task-name').value.trim() === '') {
                    closeModal('add-task-modal');
                } else {
                    document.getElementById('save-new-task-btn').click();
                }
            }
        });

        document.getElementById('edit-task-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); saveTaskEdit(); }
        });

        document.getElementById('edit-repeat-name').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); saveRepeatEdit(); }
        });

        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) closeModal(modal.id);
            });
        });
    }

    function openModal(modalId) {
        document.getElementById(modalId).classList.add('active');
		renderFloatingTaskBar();
    }

    function closeModal(modalId) {
        document.getElementById(modalId).classList.remove('active');
        if (modalId === 'task-edit-modal') {
            state.editingTaskDateKey = null;
            state.editingTaskId = null;
        }
		renderFloatingTaskBar();
    }

    function render() {
        const activeTab = document.querySelector('.tab-link.active').dataset.tab;
        if (activeTab === 'today') renderTodayTasks();
        else if (activeTab === 'repeat') renderRepeatTasks();
        else if (activeTab === 'projects') renderProjects();
        else if (activeTab === 'archive') renderArchive();
        updateProjectDropdowns();
        calculateAllEstimates();
		updateTitle();
		renderFloatingTaskBar();
    }

    function renderTodayTasks() {
        const container = document.getElementById('sections-container');
        container.innerHTML = '';
        
        const viewDateObj = new Date(state.viewDate);
        const todayStr = getFormattedDate(new Date());
        let dateLabel = viewDateObj.toLocaleDateString('ja-JP', { month: 'long', day: 'numeric', weekday: 'short' });

        document.getElementById('view-date-display').textContent = dateLabel;

        const prevBtn = document.getElementById('prev-day-btn');
        if (state.viewDate <= todayStr) {
            prevBtn.style.visibility = 'hidden';
        } else {
            prevBtn.style.visibility = 'visible';
        }

        const tasks = getTasksForViewDate();
        if (tasks.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">タスクはありません。[N]キーで追加できます。</p>`;
            return;
        }

        if (isMobile()) {
            renderTaskCards(container);
        } else {
            renderTaskTable(container);
        }

        const focusedEl = document.querySelector('.task-row.focused, .task-card.focused');
        if (focusedEl) focusedEl.scrollIntoView({ block:'nearest', behavior:'smooth' });
    }

    function renderTaskTable(container) {
        const tasks = getTasksForViewDate();
        const wrapper = document.createElement('div');
        wrapper.className = 'bg-white shadow-md';

        const tableContainer = document.createElement('div');
        tableContainer.className = 'overflow-x-auto';

        const table = document.createElement('table');
        table.className = 'min-w-full task-table';
        table.innerHTML = `
            <thead class="bg-gray-50">
                <tr>
                    <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                    <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-8"></th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">見積</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">実績</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">開始</th>
                    <th class="text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-24">終了</th>
                    <th class="text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-28">操作</th>
                </tr>
            </thead>
            <tbody id="task-table-body"></tbody>
        `;

        const tbody = table.querySelector('tbody');
        tasks.forEach((task, index) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const tr = document.createElement('tr');
            tr.className = `border-b task-row ${task.status === 'completed' ? 'bg-gray-100 text-gray-500' : ''} ${task.status === 'running' ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}`;
            tr.dataset.taskId = task.id;
            tr.dataset.index = index;
            tr.draggable = true;

            const isRunning = task.status === 'running';
            const isCompleted = task.status === 'completed';

            let timerButtonHtml = '';
            if(isCompleted) {
                timerButtonHtml = `
                <button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300 cursor-pointer items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                </button>`;
            } else {
                 timerButtonHtml = `<button class="timer-btn rounded-full transition-colors duration-200 ${isRunning ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}">
                    ${isRunning ? '■' : '▶'}
                </button>`;
            }
            
            const subtasks = task.subtasks || [];
            let subtaskIconHtml = '';
            if (subtasks.length > 0) {
                const completedCount = subtasks.filter(st => st.completed).length;
                subtaskIconHtml = `
                <span class="subtask-toggle-icon" data-task-id="${task.id}" title="サブタスク (S)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 mb-0.5" viewBox="0 0 20 20" fill="currentColor">
                        <path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" />
                        <path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" />
                    </svg>
                </span>`;
            }

            const memoIcon = task.memo ? `
                <span class="tooltip-container memo-icon-clickable" data-task-id="${task.id}">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mb-1 ml-1 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <span class="custom-tooltip">${escapeHtml(task.memo)}</span>
                </span>` : '';
            
            const actualTimeDisplay = `<span class="font-mono time-actual">${formatTime(calculateActualTime(task))}</span>`;

            tr.innerHTML = `
                <td class="text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="text-center">${timerButtonHtml}</td>
                <td>
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-1 min-w-0">
                            <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                            <span class="pl-1 font-semibold text-sm truncate" title="${escapeHtml(task.name || '')}">${formatTaskName(task.name)}</span>
                            ${subtaskIconHtml} ${memoIcon}
                        </div>
                        <span class="text-xs text-gray-400 ml-2 whitespace-nowrap flex-shrink-0 project-label">${escapeHtml(project.name)}</span>
                    </div>
                </td>
                <td class="text-sm whitespace-nowrap">${task.estimatedTime || 0} 分</td>
                <td class="text-sm whitespace-nowrap">${actualTimeDisplay}</td>
                <td class="text-sm whitespace-nowrap font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                <td class="text-sm whitespace-nowrap font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                <td class="text-center space-x-1">
                    <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1" title="編集 (E)">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1" title="翌日に先送り (P)">
                         <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                    </button>
                    <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1" title="削除 (D)">
					    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
					</button>
                </td>
            `;
            tbody.appendChild(tr);

            if (subtasks.length > 0) {
                const subtaskTr = document.createElement('tr');
                subtaskTr.className = 'subtask-container-row';
                subtaskTr.dataset.parentTaskId = task.id;
                
                const subtaskTd = document.createElement('td');
                subtaskTd.colSpan = 8;
                
                const subtaskContainer = document.createElement('div');
                subtaskContainer.id = `subtasks-${task.id}`;
                subtaskContainer.className = `subtask-container ${state.openTaskIds.has(task.id) ? 'open' : ''}`;
                
                subtasks.forEach(st => {
                    const item = document.createElement('div');
                    item.className = `subtask-item ${st.completed ? 'completed' : ''} ${st.id === state.focusedSubtaskId ? 'focused' : ''}`;
                    item.innerHTML = `
                        <input type="checkbox" class="subtask-checkbox form-checkbox h-4 w-4 text-blue-600" data-subtask-id="${st.id}" ${st.completed ? 'checked' : ''}>
                        <span class="ml-3 text-sm flex-1">${formatTaskName(st.name)}</span>
                    `;
                    item.addEventListener('click', (e) => {
						if (e.target.matches('.subtask-checkbox')) {
                            return;
                        }
                        e.stopPropagation();
                        state.focusedTaskId = task.id;
                        state.focusedSubtaskId = st.id;
                        render();
                    });
					item.addEventListener('dblclick', (e) => {
                        e.preventDefault(); // ダブルクリック時のテキスト選択を防止
                        toggleSubtaskCompletion(task.id, st.id, !st.completed);
                    });
                    subtaskContainer.appendChild(item);
                });
                
                subtaskTd.appendChild(subtaskContainer);
                subtaskTr.appendChild(subtaskTd);
                tbody.appendChild(subtaskTr);
            }
        });

        tableContainer.appendChild(table);
        wrapper.appendChild(tableContainer);
        container.appendChild(wrapper);

        attachTaskEventListeners();
        setupDragAndDrop('.task-row', tasks);
    }

	function renderTaskCards(container) {
        const tasks = getTasksForViewDate();
        const wrapper = document.createElement('div');
        wrapper.className = 'task-card-wrapper';

        tasks.forEach((task, index) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const cardWrapper = document.createElement('div');
            const card = document.createElement('div');
            const isCompleted = task.status === 'completed';
            card.className = `task-card bg-white px-3 py-2 mt-2 shadow border-l-4 ${isCompleted ? 'completed' : ''} ${task.status === 'running' ? 'bg-blue-50' : ''} ${task.id === state.focusedTaskId ? 'focused' : ''}`;
            card.style.borderLeftColor = project.color;
            card.dataset.taskId = task.id;
            card.dataset.index = index;
            card.draggable = true;

            const isRunning = task.status === 'running';
            let timerButtonHtml = '';
            if (isCompleted) {
                 timerButtonHtml = `
                 <button class="timer-btn checkmark-btn rounded-full bg-gray-200 hover:bg-gray-300 cursor-pointer items-center justify-center">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 text-green-600" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>
                </button>`;
            } else {
                timerButtonHtml = `<button class="timer-btn rounded-full transition-colors duration-200 flex-shrink-0 ${isRunning ? 'bg-red-500 hover:bg-red-600 text-white' : 'bg-green-500 hover:bg-green-600 text-white'}">
                    ${isRunning ? '■' : '▶'}
                </button>`;
            }

            const subtasks = task.subtasks || [];
            let subtaskIconHtml = '';
            if (subtasks.length > 0) {
                const completedCount = subtasks.filter(st => st.completed).length;
                subtaskIconHtml = `
                <span class="subtask-toggle-icon ml-1" data-task-id="${task.id}" title="サブタスク (S)">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path d="M9 2a1 1 0 000 2h2a1 1 0 100-2H9z" /><path fill-rule="evenodd" d="M4 5a2 2 0 012-2 3 3 0 003 3h2a3 3 0 003-3 2 2 0 012 2v11a2 2 0 01-2 2H6a2 2 0 01-2-2V5zm3 4a1 1 0 000 2h.01a1 1 0 100-2H7zm3 0a1 1 0 000 2h3a1 1 0 100-2h-3zm-3 4a1 1 0 100 2h.01a1 1 0 100-2H7zm3 0a1 1 0 100 2h3a1 1 0 100-2h-3z" clip-rule="evenodd" /></svg>
                </span>`;
            }

            const memoIcon = task.memo ? `
                 <span class="tooltip-container memo-icon-clickable" data-task-id="${task.id}">
                     <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 mb-0.5 text-gray-400 cursor-pointer hover:text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg>
                    <span class="custom-tooltip">${escapeHtml(task.memo)}</span>
                </span>` : '';
			
			const actualTimeHtml = isCompleted ? `<span class="text-gray-600">実績: ${formatTime(calculateActualTime(task))}</span>` : '';
            card.innerHTML = `
                <div class="flex items-center gap-3">
                    <div class="flex flex-col items-center">
                        ${timerButtonHtml}
                    </div>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base truncate flex items-center pr-2" title="${escapeHtml(task.name || '')}">
                               ${formatTaskName(task.name)}
                               ${subtaskIconHtml} ${memoIcon}
                            </h3>
                             <div class="flex space-x-1 flex-shrink-0">
                                <button class="edit-task-btn text-gray-400 hover:text-blue-500 p-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                                </button>
                                <button class="postpone-task-btn text-gray-400 hover:text-yellow-500 p-1">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M13 9l3 3m0 0l-3 3m3-3H8m13 0a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                                </button>
                                <button class="delete-task-btn text-gray-400 hover:text-red-500 p-1">
								    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
								</button>
                            </div>
                        </div>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <div class="flex items-center space-x-3">
								<div class="min-w-20">
                                    <span>見積: ${task.estimatedTime || 0}分</span>
                                </div>
								${actualTimeHtml}
                            </div>
                            <div class="font-mono text-gray-400">
                                ${task.startTime ? formatClockTime(new Date(task.startTime)) : ''}
                                ${task.endTime ? ' - ' + formatClockTime(new Date(task.endTime)) : ''}
                            </div>
                        </div>
                    </div>
                </div>
            `;
            cardWrapper.appendChild(card);
            
            if (subtasks.length > 0) {
                const subtaskContainer = document.createElement('div');
                subtaskContainer.id = `subtasks-${task.id}`;
                subtaskContainer.className = `subtask-container ${state.openTaskIds.has(task.id) ? 'open' : ''}`;
                subtasks.forEach(st => {
                    const item = document.createElement('div');
                    item.className = `subtask-item ${st.completed ? 'completed' : ''} ${st.id === state.focusedSubtaskId ? 'focused' : ''}`;
                    item.innerHTML = `
                        <input type="checkbox" class="subtask-checkbox form-checkbox h-4 w-4 text-blue-600" data-subtask-id="${st.id}" ${st.completed ? 'checked' : ''}>
                        <span class="ml-3 flex-1">${formatTaskName(st.name)}</span>
                    `;
                    item.addEventListener('click', (e) => {
						if (e.target.matches('.subtask-checkbox')) {
                            return;
                        }
                        e.stopPropagation();
                        state.focusedTaskId = task.id;
                        state.focusedSubtaskId = st.id;
                        render();
                    });
					item.addEventListener('dblclick', (e) => {
                        e.preventDefault(); // ダブルタップ時のテキスト選択を防止
                        toggleSubtaskCompletion(task.id, st.id, !st.completed);
                    });
                    subtaskContainer.appendChild(item);
                });
                cardWrapper.appendChild(subtaskContainer);
            }
            wrapper.appendChild(cardWrapper);
        });

        container.appendChild(wrapper);
        attachTaskEventListeners();
        setupDragAndDrop('.task-card', tasks);
    }

    function renderArchive() {
        const dateView = document.getElementById('archive-date-view');
        const projectView = document.getElementById('archive-project-view');
		const searchView = document.getElementById('archive-search-view');
        
        dateView.classList.toggle('hidden', state.archiveView !== 'date');
        projectView.classList.toggle('hidden', state.archiveView !== 'project');
        searchView.classList.toggle('hidden', state.archiveView !== 'search');

        if (state.archiveView === 'date') {
            renderArchiveDateView();
        } else if (state.archiveView === 'project')  {
            updateArchiveProjectSelect();
            renderArchiveProjectView();
        } else if (state.archiveView === 'search') {
			const q = document.getElementById('archive-search-input').value.trim();
			renderArchiveSearchView(q);
		}
    }

    function renderArchiveDateView() {
        const dateEl = document.getElementById('archive-date');
        const listEl = document.getElementById('archive-tasks-list');
        const nextBtn = document.getElementById('next-archive-day');

        const dateObj = new Date(state.archiveViewDate);
        dateEl.textContent = dateObj.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });

        const tasksForDay = state.archivedTasks[state.archiveViewDate] || [];

        const tomorrow = new Date();
        nextBtn.disabled = state.archiveViewDate === getFormattedDate(tomorrow);
        nextBtn.classList.toggle('opacity-50', nextBtn.disabled);

        if (tasksForDay.length === 0) {
            listEl.innerHTML = '<p class="text-center text-gray-500 py-8">この日に完了したタスクはありません。</p>';
            return;
        }

        let tableHtml = '<table class="min-w-full bg-white">';
        tableHtml += `<thead class="bg-gray-50">
                    <tr>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider w-20">実績時間</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>
                        <th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>
                        <th class="py-2 px-3 text-center text-xs font-medium text-gray-500 uppercase tracking-wider w-24">操作</th>
                    </tr>
                 </thead><tbody>`;

        tasksForDay.forEach(task => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap pl-4">${escapeHtml(task.memo)}</p>` : '';
            tableHtml += `
                <tr class="border-b">
                    <td class="py-2 px-3 task-memo-cell">
                        <div class="flex items-center space-x-2">
                           <span class="inline-block w-2 h-2 rounded-full flex-shrink-0" style="background-color: ${project.color};"></span>
                           <div>
                             <span class="font-semibold">${formatTaskName(task.name)}</span>
                             <span class="text-xs text-gray-400 ml-2">${escapeHtml(project.name)}</span>
                           </div>
                        </div>
                        ${memoHtml}
                    </td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">
                         ${formatTime(calculateActualTime(task))}
                    </td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-sm font-mono whitespace-nowrap">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>
                    <td class="py-2 px-3 text-center space-x-1">
                        <button class="edit-archived-task-btn text-gray-400 hover:text-blue-500 p-1" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}" title="編集">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"></path></svg>
                        </button>
                        <button class="delete-archived-task-btn text-gray-400 hover:text-red-500 p-1" data-task-id="${task.id}" data-date-key="${state.archiveViewDate}" title="削除">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16"></path></svg>
                        </button>
                    </td>
                </tr>
            `;
        });

        tableHtml += '</tbody></table>';
        listEl.innerHTML = `<div class="archive-table-wrapper">${tableHtml}</div>`;
        attachArchiveEventListeners();
    }

    function updateArchiveProjectSelect() {
        const select = document.getElementById('archive-project-select');
        select.innerHTML = '<option value="">プロジェクトを選択</option>';
        state.projects.forEach(project => {
            select.innerHTML += `<option value="${project.id}">${escapeHtml(project.name)}</option>`;
        });
        if (state.selectedArchiveProject) {
            select.value = state.selectedArchiveProject;
        }
    }

    function renderArchiveProjectView() {
        const container = document.getElementById('archive-project-tasks');
        
        if (!state.selectedArchiveProject) {
            container.innerHTML = '<p class="text-center text-gray-500 py-8">プロジェクトを選択してください。</p>';
            return;
        }

        const selectedProject = state.projects.find(p => p.id === state.selectedArchiveProject);
        if (!selectedProject) {
            container.innerHTML = '<p class="text-center text-gray-500 py-8">選択されたプロジェクトが見つかりません。</p>';
            return;
        }

        const projectTasks = {};
        Object.keys(state.archivedTasks).forEach(date => {
            const tasksForDate = state.archivedTasks[date].filter(task => task.projectId === state.selectedArchiveProject);
            if (tasksForDate.length > 0) {
                projectTasks[date] = tasksForDate;
            }
        });

        const sortedDates = Object.keys(projectTasks).sort().reverse();

        if (sortedDates.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(selectedProject.name)}」で完了したタスクはありません。</p>`;
            return;
        }

        let html = '';
        sortedDates.forEach(date => {
            const dateObj = new Date(date);
            const dateLabel = dateObj.toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'long' });
            
            html += `<div class="mb-6">
                        <h3 class="font-bold text-lg mb-3 pb-2 border-b" style="color: ${selectedProject.color}">${dateLabel}</h3>
                        <div class="space-y-2">`;
            
            projectTasks[date].forEach(task => {
                const memoHtml = task.memo ? `<p class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</p>` : '';
                html += `
                    <div class="bg-gray-50 p-3 rounded">
                        <div class="flex justify-between items-start">
                            <div>
                                <span class="font-semibold">${formatTaskName(task.name)}</span>
                                ${memoHtml}
                            </div>
                            <span class="text-sm font-mono text-gray-600">
                                ${formatTime(calculateActualTime(task))}
                            </span>
                        </div>
                    </div>
                `;
            });
            
            html += `</div></div>`;
        });

        container.innerHTML = html;
    }

    function renderArchiveSearchView(query) {
        const container = document.getElementById('archive-search-results');
        const q = (query || '').trim();
        if (!q) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">検索語を入力して「検索」ボタンを押してください。</p>`;
            return;
        }

        const normalized = q.toLowerCase();
        const results = [];

        Object.entries(state.archivedTasks).forEach(([dateKey, tasks]) => {
            tasks.forEach(task => {
                const name = (task.name || '').toLowerCase();
                const memo = (task.memo || '').toLowerCase();
                if (name.includes(normalized) || memo.includes(normalized)) {
                    results.push({ date: dateKey, task });
                }
            });
        });

        if (results.length === 0) {
            container.innerHTML = `<p class="text-center text-gray-500 py-8">「${escapeHtml(q)}」に一致するアーカイブ済みタスクは見つかりませんでした。</p>`;
            return;
        }

        results.sort((a, b) => (a.date < b.date ? 1 : a.date > b.date ? -1 : 0));

        let tableHtml = '<table class="min-w-full bg-white"><thead class="bg-gray-50"><tr>';
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">完了日</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">タスク</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">プロジェクト</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">実績時間</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">開始</th>`;
        tableHtml += `<th class="py-2 px-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">終了</th>`;
        tableHtml += `</tr></thead><tbody>`;

        results.forEach(({ date, task }) => {
            const project = state.projects.find(p => p.id === task.projectId) || { name: '', color: '#cccccc' };
            const memoHtml = task.memo ? `<div class="text-xs text-gray-500 mt-1 whitespace-pre-wrap">${escapeHtml(task.memo)}</div>` : '';
            const dateLabel = new Date(date).toLocaleDateString('ja-JP', { year: 'numeric', month: '2-digit', day: '2-digit', weekday: 'short' });

            tableHtml += `<tr class="border-b">`;
            tableHtml += `<td class="py-2 px-3">${dateLabel}</td>`;
            tableHtml += `<td class="py-2 px-3 task-memo-cell">${formatTaskName(task.name)}${memoHtml}</td>`;
            tableHtml += `<td class="py-2 px-3">${escapeHtml(project.name)}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${formatTime(calculateActualTime(task))}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${task.startTime ? formatClockTime(new Date(task.startTime)) : '--:--'}</td>`;
            tableHtml += `<td class="py-2 px-3 font-mono">${task.endTime ? formatClockTime(new Date(task.endTime)) : '--:--'}</td>`;
            tableHtml += `</tr>`;
        });

        tableHtml += '</tbody></table>';
        container.innerHTML = `<div class="archive-table-wrapper">${tableHtml}</div>`;
    }

    function attachTaskEventListeners() {
        document.querySelectorAll('.task-row, .task-card').forEach(el => {
            el.addEventListener('click', (e) => {
                if (e.target.closest('button, a, .memo-icon-clickable, .subtask-toggle-icon, .subtask-checkbox')) {
                    return;
                }
                const taskId = e.currentTarget.dataset.taskId;
                if (state.focusedTaskId !== taskId || state.focusedSubtaskId !== null) {
                    state.focusedTaskId = taskId;
                    state.focusedSubtaskId = null;
                    renderTodayTasks();
                }
            });
        });

        document.querySelectorAll('.timer-btn, .checkmark-btn').forEach(btn => 
            btn.addEventListener('click', (e) => toggleTimer(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.delete-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => deleteTask(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.postpone-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => postponeTask(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        document.querySelectorAll('.edit-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => openTaskEditModal(e.currentTarget.closest('[data-task-id]').dataset.taskId))
        );
        
        document.querySelectorAll('.memo-icon-clickable').forEach(icon => 
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                openMemoEditModal(e.currentTarget.dataset.taskId);
            })
        );
        
        document.querySelectorAll('.subtask-toggle-icon').forEach(icon => {
            icon.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleSubtaskView(e.currentTarget.dataset.taskId);
            });
        });
        
        document.querySelectorAll('.subtask-checkbox').forEach(checkbox => {
            checkbox.addEventListener('change', (e) => {
                const subtaskId = e.target.dataset.subtaskId;
                const subtaskRow = e.target.closest('[data-parent-task-id]');
                const cardWrapper = e.target.closest('.task-card-wrapper > div');
                let taskId = null;
                if (subtaskRow) {
                    taskId = subtaskRow.dataset.parentTaskId;
                } else if (cardWrapper) {
                    const card = cardWrapper.querySelector('[data-task-id]');
                    if(card) taskId = card.dataset.taskId;
                }
                if(taskId) {
                    toggleSubtaskCompletion(taskId, subtaskId, e.target.checked);
                } else {
                    console.error("Could not find parent task ID for subtask.");
                }
            });
        });
    }

    function attachArchiveEventListeners() {
        document.querySelectorAll('.edit-archived-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => openArchivedTaskEditModal(e.currentTarget.dataset.dateKey, e.currentTarget.dataset.taskId))
        );
        document.querySelectorAll('.delete-archived-task-btn').forEach(btn => 
            btn.addEventListener('click', (e) => deleteArchivedTask(e.currentTarget.dataset.dateKey, e.currentTarget.dataset.taskId))
        );
    }
    
	function setupDragAndDrop(selector, list, type = 'daily') {
	    const elements = document.querySelectorAll(selector);
	    let draggedIndex = null;
	
	    elements.forEach(el => {
	        el.addEventListener('dragstart', (e) => {
	            draggedIndex = parseInt(el.dataset.index, 10);
	            e.dataTransfer.setData('text/plain', draggedIndex);
	
	            const rect = el.getBoundingClientRect();
	
	            const pointerX = (typeof e.clientX === 'number') ? e.clientX : (rect.left + rect.width / 2);
	            const pointerY = (typeof e.clientY === 'number') ? e.clientY : (rect.top + rect.height / 2);
	            let offsetX = Math.round(pointerX - rect.left);
	            let offsetY = Math.round(pointerY - rect.top);
	
	            const dragImage = el.cloneNode(true);
	            dragImage.style.position = 'absolute';
	            dragImage.style.top = '-9999px';
	            dragImage.style.left = '-9999px';
	            dragImage.style.width = el.offsetWidth + 'px';
	            dragImage.style.boxSizing = 'border-box';
				dragImage.style.background = '#ffffff';
	
	            const originalCells = el.querySelectorAll('td, th');
	            const clonedCells = dragImage.querySelectorAll('td, th');
	            originalCells.forEach((cell, index) => {
	                if (clonedCells[index]) {
	                    clonedCells[index].style.width = cell.offsetWidth + 'px';
	                    clonedCells[index].style.minWidth = cell.offsetWidth + 'px';
	                    clonedCells[index].style.maxWidth = cell.offsetWidth + 'px';
	                    clonedCells[index].style.boxSizing = 'border-box';
	                }
	            });
	
	            dragImage.querySelectorAll('.custom-tooltip').forEach(tip => tip.remove());
	            document.body.appendChild(dragImage);
	
	            const imgWidth = dragImage.offsetWidth || rect.width;
	            const imgHeight = dragImage.offsetHeight || rect.height;
	
	            if (offsetX < 0) offsetX = 0;
	            if (offsetY < 0) offsetY = 0;
	            if (offsetX > imgWidth) offsetX = imgWidth;
	            if (offsetY > imgHeight) offsetY = imgHeight;
	
	            try {
	                e.dataTransfer.setDragImage(dragImage, offsetX, offsetY);
	            } catch (err) {
	                e.dataTransfer.setDragImage(dragImage, 0, 0);
	            }
	
	            setTimeout(() => {
	                el.classList.add('dragging');
	                if (dragImage.parentElement) document.body.removeChild(dragImage);
	            }, 0);
	        });
	
	        el.addEventListener('dragend', () => {
	            el.classList.remove('dragging');
	            draggedIndex = null;
	            document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
	        });
	
	        el.addEventListener('dragover', (e) => {
	            e.preventDefault();
	            const target = e.target.closest(selector);
	            if (target && parseInt(target.dataset.index, 10) !== draggedIndex) {
	                document.querySelectorAll('.drag-over').forEach(item => item.classList.remove('drag-over'));
	                target.classList.add('drag-over');
	            }
	        });
	
	        el.addEventListener('dragleave', (e) => {
	            e.target.closest(selector)?.classList.remove('drag-over');
	        });
	
	        el.addEventListener('drop', (e) => {
	            e.preventDefault();
	            const target = e.target.closest(selector);
	            target?.classList.remove('drag-over');
	
	            const fromIndex = draggedIndex;
	            const toIndex = parseInt(target.dataset.index, 10);
	
	            if (fromIndex !== null && fromIndex !== toIndex) {
	                const movedItem = list.splice(fromIndex, 1)[0];
	                list.splice(toIndex, 0, movedItem);
	
	                if (type === 'daily') {
	                    setTasksForViewDate(list);
	                } else if (type === 'repeat') {
	                    state.repeatTasks = list;
	                } else if (type === 'project') {
	                    state.projects = list;
	                }
	
	                saveAndRender();
	            }
	        });
	    });
	}


	function openAddTaskModal() {
	    document.getElementById('new-task-name').value = '';
	    document.getElementById('new-task-time').value = '5';
	    document.getElementById('new-task-project').value = '';
	    openModal('add-task-modal');
		const input = document.getElementById('new-task-name');
	    input.focus();
	}
    
    function openTaskEditModal(id) {
        const task = getTasksForViewDate().find(t => t.id === id);
        if (!task) return;

        state.editingTaskId = id;
        document.getElementById('edit-task-name').value = task.name || '';
        document.getElementById('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-task-project').value = task.projectId || '';
        document.getElementById('edit-task-memo').value = task.memo || '';
		
        setTimeout(() => {
            const memoTextarea = document.getElementById('edit-task-memo');
            memoTextarea.style.height = 'auto';
            memoTextarea.style.height = (memoTextarea.scrollHeight) + 'px';
        }, 0);
        
        const subtaskToggle = document.getElementById('task-subtask-toggle');
        const subtaskContent = document.getElementById('task-subtask-content');
        const hasSubtasks = task.subtasks && task.subtasks.length > 0;
        subtaskToggle.checked = hasSubtasks;
        subtaskContent.classList.toggle('hidden', !hasSubtasks);
        
        const newToggle = subtaskToggle.cloneNode(true);
        subtaskToggle.parentNode.replaceChild(newToggle, subtaskToggle);
        newToggle.addEventListener('change', () => {
            subtaskContent.classList.toggle('hidden', !newToggle.checked);
        });

        renderSubtasksInModal('task', task.id);
        const newSubtaskInput = document.getElementById('new-subtask-name');
        const addSubtaskBtn = document.getElementById('add-subtask-btn');
        newSubtaskInput.value = '';
        const addSubtaskHandler = () => {
            const subtaskName = newSubtaskInput.value.trim();
            if (subtaskName) {
                addSubtaskToModal('task', subtaskName);
                newSubtaskInput.value = '';
                newSubtaskInput.focus();
            }
        };
        addSubtaskBtn.replaceWith(addSubtaskBtn.cloneNode(true));
        document.getElementById('add-subtask-btn').addEventListener('click', addSubtaskHandler);
        newSubtaskInput.addEventListener('keydown', (e) => {
             if(e.key === 'Enter') {
                e.preventDefault();
                addSubtaskHandler();
             }
        });


        const startTimeInput = document.getElementById('edit-task-startTime');
        const endTimeInput = document.getElementById('edit-task-endTime');
        
        startTimeInput.value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        endTimeInput.value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        
        document.getElementById('create-repeat-from-task').style.display = 'block';
        openModal('task-edit-modal');
		const input = document.getElementById('edit-task-name');
        input.focus();
    }
    
    function openArchivedTaskEditModal(dateKey, taskId) {
        if (!state.archivedTasks[dateKey]) return;
        const task = state.archivedTasks[dateKey].find(t => t.id === taskId);
        if (!task) return;

        state.editingTaskId = taskId;
        state.editingTaskDateKey = dateKey; 

        document.getElementById('edit-task-name').value = task.name || '';
        document.getElementById('edit-task-time').value = task.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-task-project').value = task.projectId || '';
        document.getElementById('edit-task-memo').value = task.memo || '';
        
        const startTimeInput = document.getElementById('edit-task-startTime');
        const endTimeInput = document.getElementById('edit-task-endTime');
        
        startTimeInput.value = task.startTime ? new Date(task.startTime).toTimeString().slice(0, 5) : '';
        endTimeInput.value = task.endTime ? new Date(task.endTime).toTimeString().slice(0, 5) : '';
        
        document.getElementById('create-repeat-from-task').style.display = 'none';
        openModal('task-edit-modal');
		const input = document.getElementById('edit-task-name');
        input.focus();
    }


	function openMemoEditModal(id) {
	    const task = getTasksForViewDate().find(t => t.id === id);
	    if (!task) return;
	
	    state.editingMemoTaskId = id;
	    const memoTextEl = document.getElementById('edit-memo-text');
	    memoTextEl.value = task.memo || '';
	    openModal('memo-edit-modal');
	    memoTextEl.focus();
	}


    function saveMemoEdit() {
        const task = getTasksForViewDate().find(t => t.id === state.editingMemoTaskId);
        if (!task) return;

        const memo = document.getElementById('edit-memo-text').value.trim();
        task.memo = memo;

        closeModal('memo-edit-modal');
		task.updatedAt = new Date().toISOString();
        saveAndRender();
    }

    function saveTaskEdit() {
        const tasks = state.editingTaskDateKey 
            ? state.archivedTasks[state.editingTaskDateKey] 
            : getTasksForViewDate();
        
        if (!tasks) {
            closeModal('task-edit-modal');
            return;
        }

        const task = tasks.find(t => t.id === state.editingTaskId);
        if (!task) {
            closeModal('task-edit-modal');
            return;
        }

        const name = document.getElementById('edit-task-name').value.trim();
        const time = parseInt(document.getElementById('edit-task-time').value, 10);
        const projectId = document.getElementById('edit-task-project').value || null;
        const memo = document.getElementById('edit-task-memo').value.trim();

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        task.name = name;
        task.estimatedTime = time;
        task.projectId = projectId;
        task.memo = memo;
        
        task.subtasks = getSubtasksFromModal('task');

        const startTimeValue = document.getElementById('edit-task-startTime').value;
        const endTimeValue = document.getElementById('edit-task-endTime').value;

        if (startTimeValue) {
            const baseDate = task.startTime ? new Date(task.startTime) : (task.createdDate ? new Date(task.createdDate) : new Date());
            const [hours, minutes] = startTimeValue.split(':');
            baseDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            task.startTime = baseDate.toISOString();
        } else {
            task.startTime = null;
        }

        if (endTimeValue) {
            const baseDate = task.endTime ? new Date(task.endTime) : (task.startTime ? new Date(task.startTime) : new Date());
            const [hours, minutes] = endTimeValue.split(':');
            baseDate.setHours(parseInt(hours, 10), parseInt(minutes, 10), 0, 0);
            task.endTime = baseDate.toISOString();
        } else {
            task.endTime = null;
        }
        
        task.actualTime = calculateActualTime(task);
        
        if (!state.editingTaskDateKey) {
            updateTaskStatus(task);
        }

        closeModal('task-edit-modal');
		task.updatedAt = new Date().toISOString();
        saveAndRender();
    }

    function createRepeatFromTask() {
        const task = getTasksForViewDate().find(t => t.id === state.editingTaskId);
        if (!task) return;

        const name = document.getElementById('edit-task-name').value.trim();
        const time = parseInt(document.getElementById('edit-task-time').value, 10);
        const projectId = document.getElementById('edit-task-project').value || null;

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        state.repeatTasks.push({
            id: 'rt' + Date.now(),
            name: name,
            estimatedTime: time,
            projectId: projectId,
            memo: task.memo || '',
			subtasks: JSON.parse(JSON.stringify(task.subtasks || [])),
            type: 'daily',
            value: null,
            startDate: null
        });

        closeModal('task-edit-modal');
        alert('リピートタスクを作成しました（毎日設定）。リピートタスクタブで詳細を編集できます。');
        saveAndRender();
    }

    function openRepeatEditModal(id) {
        const repeatTask = state.repeatTasks.find(rt => rt.id === id);
        if (!repeatTask) return;

        state.editingRepeatId = id;
        document.getElementById('edit-repeat-name').value = repeatTask.name || '';
        document.getElementById('edit-repeat-time').value = repeatTask.estimatedTime || 0;
        updateProjectDropdowns();
        document.getElementById('edit-repeat-project').value = repeatTask.projectId || '';
        document.getElementById('edit-repeat-memo').value = repeatTask.memo || '';
        document.getElementById('edit-repeat-type').value = repeatTask.type || 'daily';

		setTimeout(() => {
            const memoTextarea = document.getElementById('edit-repeat-memo');
            memoTextarea.style.height = 'auto';
            memoTextarea.style.height = (memoTextarea.scrollHeight) + 'px';
        }, 0);

        const subtaskToggle = document.getElementById('repeat-subtask-toggle');
        const subtaskContent = document.getElementById('repeat-subtask-content');
        const hasSubtasks = repeatTask.subtasks && repeatTask.subtasks.length > 0;
        subtaskToggle.checked = hasSubtasks;
        subtaskContent.classList.toggle('hidden', !hasSubtasks);
        
        const newToggle = subtaskToggle.cloneNode(true);
        subtaskToggle.parentNode.replaceChild(newToggle, subtaskToggle);
        newToggle.addEventListener('change', () => {
            subtaskContent.classList.toggle('hidden', !newToggle.checked);
        });
        
        renderSubtasksInModal('repeat', repeatTask.id);
        const newSubtaskInput = document.getElementById('new-repeat-subtask-name');
        const addSubtaskBtn = document.getElementById('add-repeat-subtask-btn');
        newSubtaskInput.value = '';
        const addSubtaskHandler = () => {
            const subtaskName = newSubtaskInput.value.trim();
            if (subtaskName) {
                addSubtaskToModal('repeat', subtaskName);
                newSubtaskInput.value = '';
                newSubtaskInput.focus();
            }
        };
        addSubtaskBtn.replaceWith(addSubtaskBtn.cloneNode(true));
        document.getElementById('add-repeat-subtask-btn').addEventListener('click', addSubtaskHandler);
        newSubtaskInput.addEventListener('keydown', (e) => {
             if(e.key === 'Enter') {
                e.preventDefault();
                addSubtaskHandler();
             }
        });


        const weeklyContainer = document.getElementById('edit-repeat-weekly-options');
        if (weeklyContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyContainer.innerHTML += `<label class="inline-flex items-center mr-3"><input type="checkbox" value="${i}"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }

        document.querySelectorAll('#edit-repeat-weekly-options input').forEach(cb => cb.checked = false);
        document.getElementById('edit-repeat-monthly-day').value = '';
        document.getElementById('edit-repeat-interval-days').value = '';
        document.getElementById('edit-repeat-interval-start-date').value = '';

        if (repeatTask.type === 'weekly' && Array.isArray(repeatTask.value)) {
            document.querySelectorAll('#edit-repeat-weekly-options input').forEach(cb => {
                cb.checked = repeatTask.value.includes(parseInt(cb.value, 10));
            });
        } else if (repeatTask.type === 'monthly') {
            document.getElementById('edit-repeat-monthly-day').value = repeatTask.value || '';
        } else if (repeatTask.type === 'interval') {
            document.getElementById('edit-repeat-interval-days').value = repeatTask.value || '';
            document.getElementById('edit-repeat-interval-start-date').value = repeatTask.startDate || '';
        }

        document.getElementById('edit-repeat-weekly-options').classList.toggle('hidden', repeatTask.type !== 'weekly');
        document.getElementById('edit-repeat-monthly-options').classList.toggle('hidden', repeatTask.type !== 'monthly');
        document.getElementById('edit-repeat-interval-options').classList.toggle('hidden', repeatTask.type !== 'interval');
        openModal('repeat-edit-modal');

		const input = document.getElementById('edit-repeat-name');
		input.focus();
    }

    function saveRepeatEdit() {
        const repeatTask = state.repeatTasks.find(rt => rt.id === state.editingRepeatId);
        if (!repeatTask) return;

        const name = document.getElementById('edit-repeat-name').value.trim();
        const time = parseInt(document.getElementById('edit-repeat-time').value, 10);
        const projectId = document.getElementById('edit-repeat-project').value || null;
        const memo = document.getElementById('edit-repeat-memo').value.trim();
        const type = document.getElementById('edit-repeat-type').value;

        if (!name || isNaN(time) || time < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return;
        }

        let value = null;
        let startDate = repeatTask.startDate || null;

        if (type === 'weekly') {
            value = Array.from(document.querySelectorAll('#edit-repeat-weekly-options input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) { alert('曜日を選択してください。'); return; }
        } else if (type === 'monthly') {
            value = parseInt(document.getElementById('edit-repeat-monthly-day').value, 10);
            if (isNaN(value) || value < 1 || value > 31) { alert('有効な日付を入力してください。'); return; }
        } else if (type === 'interval') {
            value = parseInt(document.getElementById('edit-repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) { alert('有効な間隔（日数）を入力してください。'); return; }
            const startDateInput = document.getElementById('edit-repeat-interval-start-date').value;
            if (startDateInput) {
                startDate = startDateInput;
            } else if (!startDate) {
                startDate = new Date().toISOString().slice(0,10);
            }
        }

        repeatTask.name = name;
        repeatTask.estimatedTime = time;
        repeatTask.projectId = projectId;
        repeatTask.memo = memo;
        repeatTask.type = type;
        repeatTask.value = value;
        repeatTask.startDate = startDate;
        repeatTask.subtasks = getSubtasksFromModal('repeat');

        closeModal('repeat-edit-modal');
        saveAndRender();
    }

    function renderProjects() {
        const container = document.getElementById('projects-container');
        if (isMobile()) {
            renderProjectCards(container);
        } else {
            renderProjectTable(container);
        }
    }

    function renderProjectTable(container) {
        container.innerHTML = `<div class="overflow-x-auto">
            <table class="min-w-full bg-white">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-4 border-b w-8"></th>
                        <th class="py-2 px-4 border-b w-20">色</th>
                        <th class="py-2 px-4 border-b text-left">プロジェクト名</th>
                        <th class="py-2 px-4 border-b">操作</th>
                    </tr>
                </thead>
                <tbody id="projects-list"></tbody>
            </table>
        </div>`;
        const list = document.getElementById('projects-list');
        list.innerHTML = '';
        state.projects.forEach((p, idx) => {
            const tr = document.createElement('tr');
            tr.className = 'border-b project-row';
            tr.dataset.id = p.id;
            tr.dataset.index = idx;
            tr.draggable = true;
            tr.innerHTML = `
                <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="pt-2 px-4 text-center"><span class="inline-block w-4 h-4 rounded-full" style="background-color: ${p.color};"></span></td>
                <td class="py-2 px-4">${escapeHtml(p.name)}</td>
                <td class="py-2 px-4 text-center space-x-1">
                    <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </td>
            `;
            list.appendChild(tr);
        });

        setupDragAndDrop('.project-row', state.projects, 'project');
        container.querySelectorAll('.edit-project-btn').forEach(btn => btn.addEventListener('click', (e) => editProject(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-project-btn').forEach(btn => btn.addEventListener('click', (e) => deleteProject(e.currentTarget.dataset.id)));
    }

    function renderProjectCards(container) {
        container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'space-y-3';
        state.projects.forEach((p, idx) => {
            const card = document.createElement('div');
            card.className = 'bg-white p-3 shadow rounded-lg flex items-center gap-3 project-row';
            card.dataset.id = p.id;
            card.dataset.index = idx;
            card.draggable = true;
            card.innerHTML = `
                <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move">⋮⋮</span>
                <span class="inline-block w-5 h-5 rounded-full flex-shrink-0" style="background-color: ${p.color};"></span>
                <span class="flex-1 font-semibold truncate">${escapeHtml(p.name)}</span>
                <div class="space-x-1">
                    <button class="edit-project-btn text-gray-400 hover:text-blue-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg>
                    </button>
                    <button class="delete-project-btn text-gray-400 hover:text-red-500 p-1" data-id="${p.id}">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg>
                    </button>
                </div>
            `;
            wrapper.appendChild(card);
        });
        container.appendChild(wrapper);
        setupDragAndDrop('.project-row', state.projects, 'project');
        container.querySelectorAll('.edit-project-btn').forEach(btn => btn.addEventListener('click', (e) => editProject(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-project-btn').forEach(btn => btn.addEventListener('click', (e) => deleteProject(e.currentTarget.dataset.id)));
    }

    function renderRepeatTasks() {
        const container = document.getElementById('repeat-tasks-container');
        const weeklyOptionsContainer = document.getElementById('repeat-weekly-options');
        if (weeklyOptionsContainer.childElementCount === 0) {
            ['日','月','火','水','木','金','土'].forEach((d, i) => {
                weeklyOptionsContainer.innerHTML += `<label class="inline-flex items-center mr-3"><input type="checkbox" value="${i}"><span class="ml-2 text-sm">${d}</span></label>`;
            });
        }

        if (isMobile()) {
            renderRepeatTaskCards(container);
        } else {
            renderRepeatTaskTable(container);
        }
    }

    function renderRepeatTaskTable(container) {
        container.innerHTML = `<div class="overflow-x-auto">
            <table class="min-w-full bg-white">
                <thead class="bg-gray-100">
                    <tr>
                        <th class="py-2 px-4 border-b w-8"></th>
                        <th class="py-2 px-4 border-b text-left">タスク名</th>
                        <th class="py-2 px-4 border-b text-left">プロジェクト</th>
                        <th class="py-2 px-4 border-b text-left">見積時間</th>
                        <th class="py-2 px-4 border-b text-left">繰り返し</th>
                        <th class="py-2 px-4 border-b">操作</th>
                    </tr>
                </thead>
                <tbody id="repeat-tasks-list"></tbody>
            </table>
        </div>`;
        const list = container.querySelector('#repeat-tasks-list');
        list.innerHTML = '';
        
        state.repeatTasks.forEach((rt, idx) => {
            const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A' };
            let repeatText = '';
            if (rt.type === 'daily') repeatText = '毎日';
            else if (rt.type === 'weekly') repeatText = `毎週 ${Array.isArray(rt.value) ? rt.value.map(i => ['日','月','火','水','木','金','土'][i]).join(',') : ''}`;
            else if (rt.type === 'monthly') repeatText = `毎月 ${rt.value}日`;
            else if (rt.type === 'interval') repeatText = `${rt.value}日ごと (基準日: ${rt.startDate || '未設定'})`;

            const memoIcon = rt.memo ? `<span class="tooltip-container"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';

            const tr = document.createElement('tr');
            tr.className = 'border-b repeat-task-row';
            tr.dataset.id = rt.id;
            tr.dataset.index = idx;
            tr.draggable = true;
            tr.innerHTML = `
                <td class="py-2 px-4 text-center"><span class="drag-handle">⋮⋮</span></td>
                <td class="py-2 px-4"><div class="flex items-center">${formatTaskName(rt.name)}${memoIcon}</div></td>
                <td class="py-2 px-4">${escapeHtml(project.name)}</td>
                <td class="py-2 px-4">${rt.estimatedTime} 分</td>
                <td class="py-2 px-4 text-sm">${escapeHtml(repeatText)}</td>
                <td class="py-2 px-4 text-center space-x-1 whitespace-nowrap">
                    <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" data-id="${rt.id}" title="今日のタスクとして生成"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
                    <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
                    <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
                </td>
            `;
            list.appendChild(tr);
        });
        
        setupDragAndDrop('.repeat-task-row', state.repeatTasks, 'repeat');
        container.querySelectorAll('.generate-single-repeat-btn').forEach(btn => btn.addEventListener('click', (e) => generateSingleRepeatTask(e.currentTarget.dataset.id)));
        container.querySelectorAll('.edit-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => openRepeatEditModal(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => deleteRepeatTask(e.currentTarget.dataset.id)));
    }

    function renderRepeatTaskCards(container) {
        container.innerHTML = '';
        const wrapper = document.createElement('div');
        wrapper.className = 'space-y-3';
        state.repeatTasks.forEach((rt, idx) => {
            const project = state.projects.find(p => p.id === rt.projectId) || { name: 'N/A', color: '#cccccc' };
            let repeatText = '';
            if (rt.type === 'daily') repeatText = '毎日';
            else if (rt.type === 'weekly') repeatText = `毎週 ${Array.isArray(rt.value) ? rt.value.map(i => ['日','月','火','水','木','金','土'][i]).join(',') : ''}`;
            else if (rt.type === 'monthly') repeatText = `毎月 ${rt.value}日`;
            else if (rt.type === 'interval') repeatText = `${rt.value}日ごと`;

            const card = document.createElement('div');
            card.className = 'bg-white p-3 shadow border-l-4 repeat-task-row';
            card.style.borderLeftColor = project.color;
            card.dataset.id = rt.id;
            card.dataset.index = idx;
            card.draggable = true;

            const memoIcon = rt.memo ? `<span class="tooltip-container"><svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block ml-1 text-gray-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" /></svg><span class="custom-tooltip">${escapeHtml(rt.memo)}</span></span>` : '';

            card.innerHTML = `
                <div class="flex items-start gap-3">
                    <span class="drag-handle text-gray-400 hover:text-gray-600 cursor-move pt-1">⋮⋮</span>
                    <div class="flex-1 min-w-0">
                        <div class="flex justify-between items-start">
                             <h3 class="font-semibold text-base flex items-center pr-2" title="${escapeHtml(rt.name || '')}">
                               ${formatTaskName(rt.name)} ${memoIcon}
                            </h3>
                             <div class="flex space-x-1 flex-shrink-0">
                                <button class="generate-single-repeat-btn text-gray-400 hover:text-green-500 p-1" data-id="${rt.id}" title="今日のタスクとして生成"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4v16m8-8H4" /></svg></button>
                                <button class="edit-repeat-task-btn text-gray-400 hover:text-blue-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" /></svg></button>
                                <button class="delete-repeat-task-btn text-gray-400 hover:text-red-500 p-1" data-id="${rt.id}"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1-1H9a1 1 0 00-1 1v3M4 7h16" /></svg></button>
                            </div>
                        </div>
                        <p class="text-sm text-gray-500">${escapeHtml(project.name)}</p>
                        <div class="flex items-center justify-between text-xs text-gray-600 mt-1">
                            <span>見積: ${rt.estimatedTime || 0}分</span>
                            <span>${escapeHtml(repeatText)}</span>
                        </div>
                    </div>
                </div>
            `;
            wrapper.appendChild(card);
        });
        container.appendChild(wrapper);

        setupDragAndDrop('.repeat-task-row', state.repeatTasks, 'repeat');
        container.querySelectorAll('.generate-single-repeat-btn').forEach(btn => btn.addEventListener('click', (e) => generateSingleRepeatTask(e.currentTarget.dataset.id)));
        container.querySelectorAll('.edit-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => openRepeatEditModal(e.currentTarget.dataset.id)));
        container.querySelectorAll('.delete-repeat-task-btn').forEach(btn => btn.addEventListener('click', (e) => deleteRepeatTask(e.currentTarget.dataset.id)));
    }


    function updateProjectDropdowns() {
        const selects = document.querySelectorAll('#new-task-project, #repeat-task-project, #edit-task-project, #edit-repeat-project');
        selects.forEach(select => {
            const cur = select.value;
            select.innerHTML = '<option value="">プロジェクトなし</option>' + state.projects.map(p => `<option value="${p.id}">${escapeHtml(p.name)}</option>`).join('');
            if (cur) select.value = cur;
        });
    }

    function addTask(name = null, time = null, projectId = null, isInterrupt = false, options = {}) {
        const taskName = name.trim();
        const estimatedTime = parseInt(time, 10);
        
        if (!taskName || isNaN(estimatedTime) || estimatedTime < 0) {
            alert('タスク名と見積時間を正しく入力してください。');
            return null;
        }

        const tasks = getTasksForViewDate();
        const newTask = {
            id: 't' + Date.now() + Math.random(),
            name: taskName,
            projectId: projectId || null,
            estimatedTime,
            actualTime: 0,
            status: 'pending',
            isInterrupt: !!isInterrupt,
            memo: '',
			subtasks: [],
            startTime: null,
            endTime: null,
            createdDate: state.viewDate,
			updatedAt: new Date().toISOString(),
            ...options
        };

        let insertIndex = tasks.length;
        if (isInterrupt) {
            const firstPendingIndex = tasks.findIndex(t => t.status !== 'completed');
            insertIndex = firstPendingIndex === -1 ? 0 : firstPendingIndex;
		} else {
		        // 未実行(pending)タスクの最初の位置を探す
		        const firstPendingIndex = tasks.findIndex(t => t.status === 'pending');
		
		        if (firstPendingIndex !== -1) {
		            insertIndex = firstPendingIndex;
		        } else {
		            const lastRunningIndex = tasks.map(t => t.status).lastIndexOf('running');
		            if (lastRunningIndex !== -1) {
		                insertIndex = lastRunningIndex + 1;
		            } else {
		                insertIndex = tasks.length;
		            }
		        }
		  }
        tasks.splice(insertIndex, 0, newTask);
        setTasksForViewDate(tasks);

        state.focusedTaskId = newTask.id;
        saveAndRender();
        return newTask;
    }

	function deleteTask(id) {
	    if (!confirm('このタスクを削除しますか？')) return;
	
	    const allTasksForDate = state.dailyTasks[state.viewDate] || [];
	    const index = allTasksForDate.findIndex(t => t.id === id);
	    if (index === -1) return;
	
	    // 1. タスクに削除フラグを立てる（論理削除）
	    const taskToDelete = allTasksForDate[index];
	    taskToDelete.isDeleted = true;
	    taskToDelete.updatedAt = new Date().toISOString();
	
	    // 2. 削除後にフォーカスする次のタスクを決定する
	    let nextFocusedTask = null;
	    // まず、削除したタスクより下にある未削除のタスクを探す
	    for (let i = index + 1; i < allTasksForDate.length; i++) {
	        if (!allTasksForDate[i].isDeleted) {
	            nextFocusedTask = allTasksForDate[i];
	            break;
	        }
	    }
	    // 下に見つからなければ、上にある未削除のタスクを探す
	    if (!nextFocusedTask) {
	        for (let i = index - 1; i >= 0; i--) {
	            if (!allTasksForDate[i].isDeleted) {
	                nextFocusedTask = allTasksForDate[i];
	                break;
	            }
	        }
	    }
	
	    // 3. stateのフォーカスIDを更新する
	    state.focusedTaskId = nextFocusedTask ? nextFocusedTask.id : null;
	
	    // 4. 状態を保存し、画面を再描画する
	    saveAndRender();
	}

    function deleteArchivedTask(dateKey, taskId) {
        if (!confirm('このアーカイブ済みタスクを削除しますか？この操作は元に戻せません。')) return;
        if (state.archivedTasks[dateKey]) {
            state.archivedTasks[dateKey] = state.archivedTasks[dateKey].filter(t => t.id !== taskId);
            if (state.archivedTasks[dateKey].length === 0) {
                delete state.archivedTasks[dateKey];
            }
        }
        saveAndRender();
    }
    
	function postponeTask(id) {
	    // isDeletedフラグを持つタスクも含めた、その日の全タスクリストを取得します
	    const allTasksForDate = state.dailyTasks[state.viewDate] || [];
	    const taskIndex = allTasksForDate.findIndex(t => t.id === id);
	    if (taskIndex === -1) return;
	
	    // 1. 翌日にタスクのコピーを追加します
	    const taskToMove = { ...allTasksForDate[taskIndex] }; // 元のタスクをコピー
	
	    const nextDay = new Date(state.viewDate);
	    nextDay.setDate(nextDay.getDate() + 1);
	    const nextDateStr = getFormattedDate(nextDay);
	    
	    if (!state.dailyTasks[nextDateStr]) {
	        state.dailyTasks[nextDateStr] = [];
	    }
	    
	    // 実行状態などをリセットし、クリーンな状態で翌日に追加します
	    taskToMove.status = 'pending';
	    taskToMove.startTime = null;
	    taskToMove.endTime = null;
	    taskToMove.actualTime = 0;
	    delete taskToMove.isDeleted; // もしisDeletedフラグが存在すれば削除
	    taskToMove.updatedAt = new Date().toISOString(); // 更新日時を最新に
	
	    state.dailyTasks[nextDateStr].unshift(taskToMove);
	
	    // 2. 元の日のタスクを物理削除せず、「論理削除」の状態にします
	    const originalTask = allTasksForDate[taskIndex];
	    originalTask.isDeleted = true;
	    originalTask.updatedAt = new Date().toISOString(); // 更新日時を記録して同期の競合を防ぎます
	
	    // 実行中のタスクだった場合はタイマーを停止します
	    if (state.activeTaskId === id) stopActiveTimer();
	    
	    // 3. フォーカスを次の適切なタスクに移動させます
	    if (state.focusedTaskId === id) {
	        let nextFocusedTask = null;
	        // 先送りしたタスクより下にある、削除されていないタスクを探します
	        for (let i = taskIndex + 1; i < allTasksForDate.length; i++) {
	            if (!allTasksForDate[i].isDeleted) {
	                nextFocusedTask = allTasksForDate[i];
	                break;
	            }
	        }
	        // 見つからなければ、上にあるタスクを探します
	        if (!nextFocusedTask) {
	            for (let i = taskIndex - 1; i >= 0; i--) {
	                if (!allTasksForDate[i].isDeleted) {
	                    nextFocusedTask = allTasksForDate[i];
	                    break;
	                }
	            }
	        }
	        state.focusedTaskId = nextFocusedTask ? nextFocusedTask.id : null;
	    }
	    
	    saveAndRender();
	    // ユーザーへのフィードバックを追加
	    showToast(`タスクを翌日に先送りしました。`);
	}

    function toggleTimer(id, forceStop = false) {
        const tasks = getTasksForViewDate();
        const task = tasks.find(t => t.id === id);
        if (!task) return;

        if (state.activeTaskId === id && !forceStop) {
            task.endTime = new Date().toISOString();
            task.actualTime = calculateActualTime(task);
            updateTaskStatus(task);
            stopActiveTimer();
            const nextTask = tasks.find(t => t.status !== 'completed');
            state.focusedTaskId = nextTask ? nextTask.id : null;
            task.updatedAt = new Date().toISOString();
        } 
        else {
            if (state.activeTaskId) {
                const runningTask = tasks.find(t => t.id === state.activeTaskId);
                if (runningTask) {
                    runningTask.endTime = new Date().toISOString();
                    runningTask.actualTime = calculateActualTime(runningTask);
                    updateTaskStatus(runningTask);
                    runningTask.updatedAt = new Date().toISOString();
                }
                stopActiveTimer();
            }

            if (!forceStop) {
                if (task.startTime && task.status !== 'running') {
                    if (confirm('このタスクは既に一度開始されています。新しいタスクとして再開しますか？')) {
                        const newTask = addTask(task.name, task.estimatedTime, task.projectId, task.isInterrupt, {
                            memo: task.memo,
                            originRepeatId: task.originRepeatId
                        });
                        task.endTime = task.endTime || new Date().toISOString();
                        task.actualTime = calculateActualTime(task);
                        updateTaskStatus(task);
                        task.updatedAt = new Date().toISOString();
                        
                        toggleTimer(newTask.id);
                        return;
                    } else {
						 task.updatedAt = new Date().toISOString();
                         saveAndRender();
                         return;
                    }
                }
                
                task.startTime = task.startTime || new Date().toISOString();
                task.endTime = null;
                updateTaskStatus(task);
                state.activeTaskId = id;
                state.focusedTaskId = id;
                task.updatedAt = new Date().toISOString();
                
                state.activeTimerId = setInterval(() => {
                    const timeEl = document.querySelector(`[data-task-id="${id}"] .time-actual`);
                    if (timeEl) {
                        timeEl.textContent = formatTime(calculateActualTime(task));
                    }
					const floatingTimeEl = document.getElementById('floating-elapsed-time');
				    if (floatingTimeEl) {
				        floatingTimeEl.textContent = formatTime(currentActualTime);
				    }
                }, 1000);
            }
        }
        saveAndRender();
    }

    function stopActiveTimer() {
        clearInterval(state.activeTimerId);
        state.activeTimerId = null;
        state.activeTaskId = null;
    }

    function addRepeatTask() {
        const name = document.getElementById('repeat-task-name').value.trim();
        const time = parseInt(document.getElementById('repeat-task-time').value, 10);
        const projectId = document.getElementById('repeat-task-project').value || null;
        const memo = document.getElementById('repeat-task-memo').value.trim();
        const type = document.getElementById('repeat-task-type').value;

        if (!name || isNaN(time) || time < 0) return alert('タスク名と見積時間を正しく入力してください。');

        let value;
        let startDate = null;
        if (type === 'weekly') {
            value = Array.from(document.querySelectorAll('#repeat-weekly-options input:checked')).map(cb => parseInt(cb.value, 10));
            if (value.length === 0) return alert('曜日を選択してください。');
        } else if (type === 'monthly') {
            value = parseInt(document.getElementById('repeat-monthly-day').value, 10);
            if (isNaN(value) || value < 1 || value > 31) return alert('有効な日付を入力してください。');
        } else if (type === 'interval') {
            value = parseInt(document.getElementById('repeat-interval-days').value, 10);
            if (isNaN(value) || value < 1) return alert('有効な間隔（日数）を入力してください。');
            const startDateInput = document.getElementById('repeat-interval-start-date').value;
            startDate = startDateInput ? startDateInput : new Date().toISOString().slice(0,10);
        }

        state.repeatTasks.push({ id: 'rt' + Date.now(), name, estimatedTime: time, projectId, memo, type, value, startDate, subtasks: [] });

        document.getElementById('repeat-task-name').value = '';
        document.getElementById('repeat-task-time').value = '';
        document.getElementById('repeat-task-memo').value = '';
        document.querySelectorAll('#repeat-weekly-options input').forEach(cb => cb.checked = false);
        document.getElementById('repeat-monthly-day').value = '';
        document.getElementById('repeat-interval-days').value = '';
        document.getElementById('repeat-interval-start-date').value = '';
        saveAndRender();
    }

    function deleteRepeatTask(id) {
        if (!confirm('このリピートタスクを削除しますか？')) return;
        state.repeatTasks = state.repeatTasks.filter(rt => rt.id !== id);
        saveAndRender();
    }

    function addProject() {
        const name = document.getElementById('project-name').value.trim();
        const color = document.getElementById('project-color').value;
        if (!name) { alert('プロジェクト名を入力してください。'); return; }
        state.projects.push({ id: 'p' + Date.now(), name, color });
        document.getElementById('project-name').value = '';
        saveAndRender();
    }

    function editProject(id) {
        const project = state.projects.find(p => p.id === id);
        if(!project) return;
        const newName = prompt('新しいプロジェクト名を入力してください:', project.name);
        if(newName && newName.trim()) {
            project.name = newName.trim();
        }
        const newColor = prompt('新しいカラーコード（例: #ff0000）を入力してください:', project.color);
        if(newColor && /^#[0-9A-Fa-f]{6}$/.test(newColor)) {
            project.color = newColor;
        }
        saveAndRender();
    }

    function deleteProject(id) {
        if (!confirm('このプロジェクトを削除しますか？')) return;
        state.projects = state.projects.filter(p => p.id !== id);
        Object.values(state.dailyTasks).flat().forEach(t => { if(t.projectId === id) t.projectId = null; });
        state.repeatTasks.forEach(rt => { if(rt.projectId === id) rt.projectId = null; });
        saveAndRender();
    }

    function exportData() {
        const exportData = {
            dailyTasks: state.dailyTasks,
            projects: state.projects,
            repeatTasks: state.repeatTasks,
            archivedTasks: state.archivedTasks,
            lastDate: state.lastDate,
            exportDate: new Date().toISOString()
        };

        const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `dtl_export_${new Date().toISOString().slice(0, 10)}.json`;
        a.click();
        URL.revokeObjectURL(url);
        
        alert('データをエクスポートしました。');
    }

    function importData() {
        const fileInput = document.getElementById('import-file');
        const file = fileInput.files[0];
        if (!file) return alert('インポートするファイルを選択してください。');
        
        if (!confirm('データをインポートします。IDが重複するデータは上書きされます。よろしいですか？')) return;

        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                
                Object.assign(state.dailyTasks, importedData.dailyTasks || {});
                Object.assign(state.archivedTasks, importedData.archivedTasks || {});

                if (importedData.projects && Array.isArray(importedData.projects)) {
                    const projectMap = new Map(state.projects.map(p => [p.id, p]));
                    importedData.projects.forEach(p => projectMap.set(p.id, p));
                    state.projects = Array.from(projectMap.values());
                }
                
                if (importedData.repeatTasks && Array.isArray(importedData.repeatTasks)) {
                    const repeatTaskMap = new Map(state.repeatTasks.map(rt => [rt.id, rt]));
                    importedData.repeatTasks.forEach(rt => repeatTaskMap.set(rt.id, rt));
                    state.repeatTasks = Array.from(repeatTaskMap.values());
                }

                state.lastDate = importedData.lastDate || state.lastDate;
                
                stopActiveTimer();
                state.viewDate = getFormattedDate(new Date());
                const tasksToday = getTasksForViewDate();
 
				const firstUncompletedTask = tasksToday.find(t => getTaskStatus(t) !== 'completed');
				if (firstUncompletedTask) {
					// 未完了タスクがあれば、その最初のタスクを選択
					state.focusedTaskId = firstUncompletedTask.id;
				} else if (tasksToday.length > 0) {
					// 未完了タスクがなく、タスクが1件以上あれば、リストの最後のタスクを選択
					state.focusedTaskId = tasksToday[tasksToday.length - 1].id;
				} else {
					// タスクがなければ選択しない
					state.focusedTaskId = null;
				}
			
                Object.values(state.dailyTasks).flat().forEach(task => updateTaskStatus(task));
                
                saveAndRender();
                alert('データをインポートしました。');
                fileInput.value = '';
            } catch (error) {
                alert('無効なファイル形式です。正しいJSONファイルを選択してください。');
                console.error('Import error:', error);
            }
        };
        reader.readAsText(file);
    }

    function clearAllData() {
        if (!confirm('本当に全てのデータを削除しますか？この操作は元に戻せません。')) return;
        if (!confirm('最終確認！全てのタスク、プロジェクト、履歴データが削除されます。')) return;
        
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('dtl_')) localStorage.removeItem(key);
        });
        
        location.reload();
    }

    function calculateAllEstimates() {
        const now = new Date();
        const unfinishedTasks = getTasksForViewDate().filter(t => t.status !== 'completed');
        const totalRemainingMinutes = unfinishedTasks.reduce((sum, task) => sum + (task.estimatedTime || 0), 0);
        totalEstimatedEndTimeEl.textContent = totalRemainingMinutes > 0 ? formatClockTime(new Date(now.getTime() + totalRemainingMinutes * 60 * 1000)) : '完了';
    }

	function renderFloatingTaskBar() {
	    const bar = document.getElementById('floating-task-bar');
	    const barContent = document.getElementById('floating-task-bar-content'); 
	    if (!bar || !barContent) return;

	    // スマホ以外、またはモーダル表示中はバーを隠す
	    if (!isMobile() || document.querySelector('.modal.active')) {
	        bar.classList.remove('active');
	        return;
	    }

	    const tasks = getTasksForViewDate();
	    const activeTask = tasks.find(t => t.id === state.activeTaskId);
	    const nextTask = tasks.find(t => getTaskStatus(t) !== 'completed');
	    const taskToDisplay = activeTask || nextTask;

		const addTaskButtonHtml = `
            <button id="add-task-btn-bar" class="floating-bar-btn bg-blue-600 hover:bg-blue-700 text-white text-3xl font-bold">
                ＋
            </button>`;

	    if (!taskToDisplay) {
			// 表示するタスクがない場合でも、バーと追加ボタンは表示する
			barContent.innerHTML = `
				<div class="flex-1 px-3 min-w-0 flex items-center">
					<p class="text-gray-500">全てのタスクが完了しました 🎉</p>
				</div>
				${addTaskButtonHtml}
			`;
			bar.classList.add('active'); // activeクラスは外側のバーに設定
			barContent.querySelector('#add-task-btn-bar').addEventListener('click', openAddTaskModal);
			return;
        }

        const isTaskRunning = !!activeTask;
        const buttonIcon = isTaskRunning ? '■' : '▶';
        const buttonColor = isTaskRunning ? 'bg-red-500 hover:bg-red-600' : 'bg-green-500 hover:bg-green-600';

        let taskInfoHtml = '';
        if (isTaskRunning) {
            const estimatedEndTime = new Date(new Date(activeTask.startTime).getTime() + (activeTask.estimatedTime * 60 * 1000));
            taskInfoHtml = `
                <p class="text-base font-bold text-gray-800 truncate" title="${escapeHtml(activeTask.name)}">${formatTaskName(activeTask.name)}</p>
	            <p class="text-gray-500 font-mono">終了予定: ${formatClockTime(estimatedEndTime)}</p>
            `;
        } else {
            taskInfoHtml = `
                <p class="text-gray-500">Next: <span class="font-bold text-gray-800 truncate" title="${escapeHtml(nextTask.name)}">${formatTaskName(nextTask.name)}</span></p>
	            <p class="text-sm text-gray-500">${nextTask.estimatedTime || 0}分</p>
            `;
        }

        const timerButtonHtml = `
            <button id="floating-timer-btn" class="floating-bar-btn ${buttonColor} text-white text-2xl">
                ${buttonIcon}
            </button>`;

		barContent.innerHTML = `
		    ${timerButtonHtml}
		    <div class="flex-1 px-3 min-w-0 cursor-pointer" 
		         id="floating-task-info"
		         data-task-id="${taskToDisplay.id}">
		        ${taskInfoHtml}
		    </div>
		    ${addTaskButtonHtml}
		`;
		
		// タップイベントのハンドリング
		const taskInfoArea = barContent.querySelector('#floating-task-info');
		if (taskInfoArea) {
		    let clickTimer = null;
		    const delay = 250; // ダブルタップの待機時間 (ミリ秒)

		    taskInfoArea.addEventListener('click', (e) => {
		        e.preventDefault();
		        // ダブルタップでないことを確認するため、タイマーを設定
		        if (clickTimer === null) {
		            clickTimer = setTimeout(() => {
		                clickTimer = null;
		                // タイマーが実行されたらシングルタップと判断し、スクロール処理を実行
		                const taskElement = document.querySelector(`[data-task-id='${taskToDisplay.id}']`);
		                if (taskElement) {
		                    taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
		                }
		            }, delay);
		        }
		    });

		    taskInfoArea.addEventListener('dblclick', (e) => {
		        e.preventDefault();
		        // シングルタップ用のタイマーが設定されていれば、それを解除
		        if (clickTimer) {
		            clearTimeout(clickTimer);
		            clickTimer = null;
		        }
		        // ダブルタップの処理（メモ編集モーダル表示）を実行
		        openMemoEditModal(taskToDisplay.id);
		    });
		}

	    bar.classList.add('active'); // activeクラスは外側のバーに設定
        barContent.querySelector('#floating-timer-btn').addEventListener('click', () => toggleTimer(taskToDisplay.id));
        barContent.querySelector('#add-task-btn-bar').addEventListener('click', openAddTaskModal);
	}

    function handleKeyboardShortcuts(e) {
        if (document.querySelector('input:focus, select:focus, textarea:focus, .modal.active')) return;
        
        const activeTab = document.querySelector('.tab-link.active').dataset.tab;

        if (activeTab === 'today') {
            handleTodayShortcuts(e);
        } else if (activeTab === 'archive') {
            handleArchiveShortcuts(e);
        }
    }

	function handleTodayShortcuts(e) {
        const tasks = getTasksForViewDate();
        // 修正箇所: タスクが0件の場合でも、左右キーでの日付移動を許可するリストに 'arrowleft' と 'arrowright' を追加
        if (tasks.length === 0 && !['n', 'r', 'arrowleft', 'arrowright'].includes(e.key.toLowerCase())) return;

        const currentTaskIndex = tasks.findIndex(t => t.id === state.focusedTaskId);
        const currentTask = (currentTaskIndex !== -1) ? tasks[currentTaskIndex] : null;

        // --- サブタスクがフォーカスされている場合の処理 ---
        if (currentTask && state.focusedSubtaskId) {
            const subtasks = currentTask.subtasks || [];
            const currentSubtaskIndex = subtasks.findIndex(st => st.id === state.focusedSubtaskId);

            if (currentSubtaskIndex !== -1) {
                switch (e.key.toLowerCase()) {
                    case 'arrowup':
                        e.preventDefault();
                        if (e.ctrlKey || e.metaKey) { // 並び替え
                            if (currentSubtaskIndex > 0) {
                                [subtasks[currentSubtaskIndex - 1], subtasks[currentSubtaskIndex]] = [subtasks[currentSubtaskIndex], subtasks[currentSubtaskIndex - 1]];
                                currentTask.updatedAt = new Date().toISOString();
                                saveAndRender();
                            }
                        } else { // 選択移動
                            if (currentSubtaskIndex > 0) {
                                state.focusedSubtaskId = subtasks[currentSubtaskIndex - 1].id;
                            } else {
                                state.focusedSubtaskId = null; // 親タスクに戻る
                            }
                            render();
                        }
                        return;
                    case 'arrowdown':
                        e.preventDefault();
                        if (e.ctrlKey || e.metaKey) { // 並び替え
                            if (currentSubtaskIndex < subtasks.length - 1) {
                                [subtasks[currentSubtaskIndex + 1], subtasks[currentSubtaskIndex]] = [subtasks[currentSubtaskIndex], subtasks[currentSubtaskIndex + 1]];
                                currentTask.updatedAt = new Date().toISOString();
                                saveAndRender();
                            }
                        } else { // 選択移動
                            if (currentSubtaskIndex < subtasks.length - 1) {
                                state.focusedSubtaskId = subtasks[currentSubtaskIndex + 1].id;
                            } else { // 最後のサブタスクから次のタスクへ
                                state.focusedSubtaskId = null;
                                if (currentTaskIndex < tasks.length - 1) {
                                    state.focusedTaskId = tasks[currentTaskIndex + 1].id;
                                    render();
                                }
                            }
                            render();
                        }
                        return;
                    case ' ':
                        e.preventDefault();
                        const subtask = subtasks[currentSubtaskIndex];
                        toggleSubtaskCompletion(currentTask.id, subtask.id, !subtask.completed);
                        return;
                }
            }
        }

        // --- 親タスクがフォーカスされている場合の処理 ---
        switch (e.key.toLowerCase()) {
            case 'n': e.preventDefault(); openAddTaskModal(); break;
            case 'e': e.preventDefault(); if (state.focusedTaskId) openTaskEditModal(state.focusedTaskId); break;
            case 'm': e.preventDefault(); if (state.focusedTaskId) openMemoEditModal(state.focusedTaskId); break;
            case 'd': e.preventDefault(); if (state.focusedTaskId) deleteTask(state.focusedTaskId); break;
            case 'p': e.preventDefault(); if (state.focusedTaskId) postponeTask(state.focusedTaskId); break;
            case 's': e.preventDefault(); if (state.focusedTaskId) toggleSubtaskView(state.focusedTaskId); break;
            case 'r':
                e.preventDefault();
                if (dailyTaskListApp.dbx) {
                    dailyTaskListApp.loadStateFromDropbox();
                }
                break;
            case 'arrowdown':
                e.preventDefault();
                if (!currentTask) {
                    if (tasks.length > 0) state.focusedTaskId = tasks[0].id;
                    render();
                    break;
                }

                // 開いているサブタスクがあれば、最初のサブタスクに移動
                const subtaskContainer = document.getElementById(`subtasks-${currentTask.id}`);
                const hasOpenSubtasks = state.openTaskIds.has(currentTask.id) && currentTask.subtasks && currentTask.subtasks.length > 0;
                if (hasOpenSubtasks) {
                    state.focusedSubtaskId = currentTask.subtasks[0].id;
                    render();
                    break;
                }
                
                if (e.ctrlKey || e.metaKey) { // 親タスクの並び替え
                    if (currentTaskIndex < tasks.length - 1) {
                        [tasks[currentTaskIndex], tasks[currentTaskIndex + 1]] = [tasks[currentTaskIndex + 1], tasks[currentTaskIndex]];
                        setTasksForViewDate(tasks);
                        saveAndRender();
                    }
                } else { // 次の親タスクへ移動
                    if (currentTaskIndex < tasks.length - 1) {
                        state.focusedTaskId = tasks[currentTaskIndex + 1].id;
                        render();
                    }
                }
                break;
            case 'arrowup':
                e.preventDefault();
                if (!currentTask) break;

                if (e.ctrlKey || e.metaKey) { // 親タスクの並び替え
                    if (currentTaskIndex > 0) {
                        [tasks[currentTaskIndex], tasks[currentTaskIndex - 1]] = [tasks[currentTaskIndex - 1], tasks[currentTaskIndex]];
                        setTasksForViewDate(tasks);
                        saveAndRender();
                    }
                } else { // 前の親タスクへ移動
                    if (currentTaskIndex > 0) {
                        const prevTask = tasks[currentTaskIndex - 1];
                        const prevSubtaskContainer = document.getElementById(`subtasks-${prevTask.id}`);
                        const prevHasOpenSubtasks = prevSubtaskContainer && prevSubtaskContainer.classList.contains('open') && prevTask.subtasks && prevTask.subtasks.length > 0;
                        
                        // 前タスクに開いているサブタスクがあれば、その最後のサブタスクに移動
                        if (prevHasOpenSubtasks) {
                            state.focusedTaskId = prevTask.id;
                            state.focusedSubtaskId = prevTask.subtasks[prevTask.subtasks.length - 1].id;
                        } else {
                            state.focusedTaskId = prevTask.id;
                        }
                        render();
                    }
                }
                break;
            case 'arrowleft': e.preventDefault(); moveViewDate(-1); break;
            case 'arrowright': e.preventDefault(); moveViewDate(1); break;
            case ' ': e.preventDefault(); if (state.focusedTaskId) toggleTimer(state.focusedTaskId); break;
        }
    }

    function handleArchiveShortcuts(e) {
        switch(e.key) {
            case 'ArrowLeft': e.preventDefault(); if (state.archiveView === 'date') moveArchiveDate(-1); break;
            case 'ArrowRight': e.preventDefault(); if (state.archiveView === 'date') moveArchiveDate(1); break;
        }
    }
    
    function moveViewDate(direction) {
        const todayStr = getFormattedDate(new Date());
        if (direction === -1 && state.viewDate <= todayStr) {
            return;
        }
        const currentDate = new Date(state.viewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.viewDate = getFormattedDate(currentDate);
        const tasks = getTasksForViewDate();
        state.focusedTaskId = tasks.length > 0 ? tasks[0].id : null;
        renderTodayTasks();
    }
    
    function moveArchiveDate(direction) {
        const currentDate = new Date(state.archiveViewDate);
        currentDate.setDate(currentDate.getDate() + direction);
        state.archiveViewDate = getFormattedDate(currentDate);
        renderArchive();
    }

    function escapeHtml(s) {
        if (!s) return '';
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;').replace(/'/g,'&#39;');
    }

    function formatTaskName(text) {
        if (!text) return '';
        let escapedText = escapeHtml(text);
        const markdownRegex = /\[(.*?)\]\((.*?)\)/g;
        escapedText = escapedText.replace(markdownRegex, (match, linkText, url) => {
            const safeUrl = url.replace(/&amp;/g, '&');
             return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${linkText}</a>`;
        });
        const urlRegex = /([a-zA-Z][a-zA-Z0-9+.-]*:\/\/\S+)/g;
        const parts = escapedText.split(/(<[^>]+>)/);
        return parts.map(part => {
             if (part.startsWith('<')) return part;
             return part.replace(urlRegex, url => {
                const safeUrl = url.replace(/&amp;/g, '&');
                return `<a href="${safeUrl}" target="_blank" rel="noopener noreferrer" class="text-blue-600 hover:underline">${url}</a>`;
            });
        }).join('');
    }
    
    function calculateActualTime(task) {
        if (task.status === 'running' && task.startTime) {
             return Math.round((new Date().getTime() - new Date(task.startTime).getTime()) / 1000);
        }
        if (task.startTime && task.endTime) {
            const duration = new Date(task.endTime).getTime() - new Date(task.startTime).getTime();
            return Math.round(Math.max(0, duration) / 1000);
        }
        return task.actualTime || 0;
    }

    function saveAndRender() { updateSortOrderAndTimestamps(state.viewDate); saveState(); render(); updateTitle(); }
    function updateTimeDisplays() {
        currentDateEl.textContent = new Date().toLocaleString('ja-JP', { year:'numeric', month:'long', day:'numeric', weekday:'long' });
        calculateAllEstimates();
    }
	function formatTime(seconds) {
        const s = parseInt(seconds, 10) || 0;
        const m = Math.floor(s / 60);
        const sec = (s % 60).toString().padStart(2,'0');
        return `${m.toString().padStart(2, '0')}:${sec}`;
    }
    function formatClockTime(date) {
        if (!date) return '--:--';
        return date.toLocaleTimeString('ja-JP', { hour:'2-digit', minute:'2-digit' });
    }

    function renderPcAddTaskButton() {
        const container = document.getElementById('add-task-floating-container');
        if (!container) return;

        container.innerHTML = `
            <button id="add-task-btn-floating" class="fab bg-blue-600 hover:bg-blue-700 text-white text-3xl font-bold">
                ＋
            </button>`;
        
        container.querySelector('#add-task-btn-floating').addEventListener('click', openAddTaskModal);
    }

    init();
});
</script>

	
</body>
</html>
